<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.control_func API documentation</title>
<meta name="description" content="Created on Sat May 16 17:57:27 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.control_func</code></h1>
</header>
<section id="section-intro">
<p>Created on Sat May 16 17:57:27 2020</p>
<p>@author: Devdutt Subhasish</p>
<p>Some common functions which will be used across multiple files, classes and files.
Also loads up the mass-inertia and kinematic parameters from the URDF.
Should be imported individually in every python file.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Sat May 16 17:57:27 2020

@author: Devdutt Subhasish

Some common functions which will be used across multiple files, classes and files.
Also loads up the mass-inertia and kinematic parameters from the URDF.
Should be imported individually in every python file.
&#34;&#34;&#34;

import numpy as np#numpy
from numba import jit
import rospy#for interfacing with ROS
from urdf_parser_py.urdf import URDF#to use URDF from ROS Parameter Server
from tf.transformations import *#to convert orientations between various conventions
import pickle
# import time
from typing import Tuple

# some functions which will be used frequently
sin=np.sin
cos=np.cos
pi=np.pi
inv=np.linalg.inv#inverse
pinv=np.linalg.pinv

@jit(nopython=True,cache=True)
def tilda(p:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns the 3x3 skew-symmetric matix corresponding to the cross-product
    operation for a given 3x1 vector.

    Parameters
    ----------
    p : list or numpy.ndarray of shape (3,1)
         3x1 input vector

    Returns
    -------
    til : numpy.ndarray of shape (3,3)
         3x3 skew-symmetric matix corresponding to the cross-product operation

    &#34;&#34;&#34;
    
    til=np.array([[0,-p[2,0],p[1,0]],[p[2,0],0,-p[0,0]],[-p[1,0],p[0,0],0]])
    return til

@jit(nopython=True,cache=True)
def inv_tilda(til:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Inverse function of the tilda function

    Parameters
    ----------
    til : numpy.ndarray of shape (3,3)
         3x3 skew-symmetric matix corresponding to the cross-product operation

    Returns
    -------
    p : numpy.ndarray of shape (3,1)
         3x1 vector corresponding to the input skew-symmetric matrix

    &#34;&#34;&#34;
    
    p=np.zeros((3,1),dtype=np.float64)
    p[0]=-til[1,2]
    p[1]=til[0,2]
    p[2]=-til[0,1]
    return p

def tilda6(P:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Tilda operation used in Spatial Vector Algebra.

    Parameters
    ---------- 
    P : list or numpy.ndarray of shape (6,)
         Input spatial vector

    Returns
    -------
    til : numpy.ndarray of shape (6,6)
         6x6 matrix corresponding to tilda operation on P
    &#34;&#34;&#34;
    
    x=P[0:3]
    y=P[3:6]
    x_tilda=tilda(x)
    y_tilda=tilda(y)
    til=np.zeros((6,6),dtype=np.float64)
    til[0:3,0:3]=x_tilda
    til[3:6,3:6]=x_tilda
    til[3:6,0:3]=y_tilda
    return til

@jit(nopython=True,cache=True)
def Rx(theta:np.float64)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about x axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         3x3 Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[1.0,0.0,0.0],
                [0.0,np.cos(theta),-np.sin(theta)],
                [0.0,np.sin(theta),np.cos(theta)]])
    return R

@jit(nopython=True,cache=True)
def Ry(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about y axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[np.cos(theta),0.0,np.sin(theta)],
                [0.0,1.0,0.0],
                [-np.sin(theta),0.0,np.cos(theta)]])
    return R

@jit(nopython=True,cache=True)
def Rz(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about z axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[np.cos(theta),-np.sin(theta),0.0],
                [np.sin(theta),np.cos(theta),0.0],
                [0.0,0.0,1.0]])
    return R

@jit(nopython=True,cache=True)
def phi_link(d:float,a:float,alpha:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns Rigid body transformation matrix corresponding to DH parameters d,a and alpha

    Parameters
    ----------
    d : float
          DH parameter d (joint offset in metres)
    a : float
          DH parameter a (link length in metres)
    alpha : float
          DH parameter alpha (link twist in radians)

    Returns
    -------
    phi_l : numpy.ndarray of shape (6,6)
          Rigid Body Transformation Matrix

    &#34;&#34;&#34;
    
    R=Rx(alpha)
    l_tilda=tilda(np.array([[a,-d*np.sin(alpha),d*np.cos(alpha)]]).T)
    phi_l=np.zeros((6,6))
    phi_l[0:3,0:3]=phi_l[3:6,3:6]=R
    phi_l[0:3,3:6]=l_tilda @ R
    
    return phi_l

@jit(nopython=True,cache=True)
def phi_hinge(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns Rigid body transformation matrix corresponding to DH parameter theta

    Parameters
    ----------
    theta : float
          DH parameter theta (joint angle in radians)

    Returns
    -------
    phi_h : numpy.ndarray of shape (6,6)
          Rigid Body Transformation Matrix

    &#34;&#34;&#34;
    phi_h=np.zeros((6,6))
    phi_h[0:3,0:3]=phi_h[3:6,3:6]=Rz(theta)
    return phi_h

@jit(nopython=True,cache=True)
def get_phi(alpha:np.ndarray,a:np.ndarray,theta0:np.ndarray,theta:np.ndarray,d:np.ndarray,a0:float,alpha0:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns a 3D arrays of rigid body transformation matrixes for all 6 joints in the Manipulator

    Parameters
    ----------
    alpha : numpy.ndarray of shape (6,1)
          array of DH parameter alpha for all 6 joints
    a : numpy.ndarray of shape (6,1)
          array of DH parameter a for all 6 joints
    theta0 : numpy.ndarray of shape (6,1)
          array of DH parameter theta_0 which is the initial joint angle at home position
    theta : numpy.ndarray of shape (6,1)
          array of DH parameter theta which is to be added to initial joint angle to get total joint angle.
    d : numpy.ndarray of shape (6,1)
          array of DH parameter d for all 6 joints
    a0 : float
          base link length
    alpha0 : float
          base link twist

    Returns
    -------
    phis : numpy.ndarray of shape (6,6,6)
          array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6. 
    phis_l : numpy.ndarray of shape (6,6,6)
          array of link Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6.
    phis_h : numpy.ndarray of shape (6,6,6)
          array of hinge Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6.
    &#34;&#34;&#34;

    phis_l=np.zeros((6,6,6))
    phis_h=np.zeros((6,6,6))
    phis=np.zeros((6,6,6))
    for i in range(6):
        if i==0 :
            phis_l[i]=phi_link(d[i,0],a0,alpha0)
        else:
            phis_l[i]=phi_link(d[i,0],a[i-1,0],alpha[i-1,0])
        phis_h[i,:,:]=phi_hinge(theta[i,0]+theta0[i,0])
        phis[i]=phis_l[i] @ phis_h[i]
    return phis,phis_l,phis_h

@jit(nopython=True,cache=True)
def get_cummulative_phi(phis:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns a array of cummulative rigid body transformation matrices.

    Parameters
    ----------
    phis : numpy.ndarray of shape (6,6,6)
          array of 6 rigid body transformation matrices phi_i-1_i for i=1 to 6

    Returns
    -------
    cphis : numpy.ndarray of shape (6,6,6)
          array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
        phi_i-1_6 for i=1 to 6. 

    &#34;&#34;&#34;
    
    cphis=np.zeros((6,6,6))
    cphis[5,:,:]=phis[5,:,:]
    for i in [4,3,2,1,0]:
        cphis[i]=phis[i]@cphis[i+1]
        
    return cphis

@jit(nopython=True,cache=True)
def pos_from_phi(phi:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the position coordinates from a rigid body transformation matrix

    Parameters
    ----------
    phi : numpy.ndarray of shape (6,6)
         rigid body transformation matrix

    Returns
    -------
    pos : numpy.ndarray
         numpy array of shape (3,1) which is the position coordinates from phi

    &#34;&#34;&#34;
    
    pos=inv_tilda(phi[0:3,3:6] @ phi[0:3,0:3].T)
    return pos

def create_IM(link)-&gt;Tuple[float,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Gets the mass-inertia properties of the link from the Robot Description (URDF) loaded in the ROS parameter server
    returns a tuple of the form (m,COM,I)
    where m is the mass of the link
    COM is the coordinates of the Centre of Mass of the link in terms of the link frame
    I is the inertia tensor w.r.t the link frames
    
    Parameters
    ----------
    link : URDF.Link
         urdf.link object corresponding to the link whose mass-inertia properties need to be extracted

    Returns
    -------
    m : float
         Mass of the link
    COM : numpy.ndarray of shape (3,)
         Coordinates of Centre of Mass of the links in terms of the link frame
    I : numpy.ndarray of shape (3,3)
         Inertia Tensor in terms of the link frame

    &#34;&#34;&#34;
    
    link=link[0]
    ixx=link.inertial.inertia.ixx
    ixy=link.inertial.inertia.ixy
    ixz=link.inertial.inertia.ixz
    iyy=link.inertial.inertia.iyy
    iyz=link.inertial.inertia.iyz
    izz=link.inertial.inertia.izz
    I=np.array([[ixx,ixy,ixz],
                [ixy,iyy,iyz],
                [ixz,iyz,izz]],dtype=np.float64)
    
    m=link.inertial.mass
    
    COM=np.array(link.inertial.origin.xyz,dtype=np.float64)

    COM=COM.reshape((3,1))

    It1=m*np.matmul(COM.T,COM)*np.eye(3,dtype=np.float64)
    It2=-m*np.matmul(COM,COM.T)

    I=I+1*It1+1*It2
    
    return m,COM.flatten(),I

def get_SM(m:list,COMs:np.ndarray,IMs:list)-&gt;list:
    &#34;&#34;&#34;returns SMs the list of 6 Link Spatial Inertia matrices.
    SMs[0]-SMs[5] are the Spatial Inertias of links 1-6.

    Parameters
    ----------
    m : list
         list of link masses
    COMs : numpy.ndarray of shape (3,6)
         array of Centres of Mass of the links
    IMs : list
         list of Inertia Tensors of the links

    Returns
    -------
    SMs : list
         list of 12 Spatial Inertia Matrices.

    &#34;&#34;&#34;
    
    SMs=np.zeros((len(m),6,6))
    for i in range(len(m)):
        SM=np.zeros((6,6),dtype=np.float64)
        SM[0:3,0:3]=IMs[i]
        til=tilda(COMs[:,i][:,np.newaxis])
        SM[0:3,3:6]=m[i]*til
        SM[3:6,0:3]=-m[i]*til
        SM[3:6,3:6]=m[i]*np.eye(3,dtype=np.float64)
        SMs[i]=SM
    return SMs    
    

@jit(nopython=True,cache=True)
def compute_D(SMs:np.ndarray, phis:np.ndarray,H:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 6x6 Joint Space Inertia Matrix D computed using the Composite Rigid Body Algorithm

    Parameters
    ----------
    SMs : np.ndarray
          np.ndarray of shape (6,6,6) of spatial inertias
    phis : numpy.ndarray of shape (6,6,6)
          array of 6 rigid body transformation matrices for frames 1 to 6
    H : numpy.ndarray
          Hinge Map Matrix

    Returns
    -------
    D : numpy.ndarray of shape (6,6)
          6x6 Joint Space Inertia Matrix

    &#34;&#34;&#34;
    
    D=np.zeros((6,6))
    R=np.zeros((6,6))
    F=np.zeros((6,1))
    R[:,:]=SMs[5]
    F[:,:]=R @ H.T
    D[5,5]=(H @ F)[0,0]
    for j in range(4,-1,-1):
        F[:,:]=phis[j+1] @ F
        D[j,5]=D[5,j]=(H @ F)[0,0]
            
    for k in range(4,-1,-1):
        R[:,:]=SMs[k]+phis[k+1] @ R @ phis[k+1].T
        F[:,:]=R @ H.T
        D[k,k]=(H @ F)[0,0]
        for j in np.arange(k-1,-1,-1):
            F[:,:]=phis[j+1] @ F
            D[j,k]=D[k,j]=(H @ F)[0,0]            
    return D

@jit(nopython=True,cache=True)
def forward_sweep(theta0:np.ndarray,theta:np.ndarray,dtheta:np.ndarray,phis:np.ndarray,H:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Carries out the forward sweep of the Recursive Newton Euler Algorithm
    
    Parameters
    ----------
    theta0 : numpy.ndarray of shape (6,1)
         array of initial joint angles at home position
    theta : numpy.ndarray of shape (6,1)
         array of additional joint angle applied from home position
    dtheta : numpy.ndarray of shape (6,1)
         array of joint velocities
    phis : numpy.ndarray of shape (6,1)
         array rigid body transformation matrices for frames 1 to 6
    H : numpy.ndarray
         Hinge Map Matrix

    Returns
    -------
    V : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial velocities
    A : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial accelerations
    g : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial acceleration due to gravity

    &#34;&#34;&#34;
    
    V=np.zeros((6,6,1))
    A=np.zeros((6,6,1))
    g=np.zeros((6,6,1))

    Vk=np.zeros((6,1))
    Ak=np.zeros((6,1))
    gk=np.zeros((6,1))
    gk[5]=-9.8
    kak=np.zeros((6,1))
    kwk=np.zeros((3,1))
    for k in np.arange(1,7,1):
        Vk[:,:]=phis[k-1].T @ Vk+H.T*dtheta[k-1]
        kwk[:,:]=(dtheta[k-1]*H.T)[0:3,:]
        kak[0:3,:]=-tilda(kwk) @ Vk[0:3]
        kak[3:6,:]=-tilda(kwk) @ Vk[3:6]
        Ak[:,:]=phis[k-1].T @ Ak+kak
        gk[:,:]=phis[k-1].T @ gk

        V[k-1,:,:]=Vk[:,:]
        A[k-1,:,:]=Ak[:,:]
        g[k-1,:,:]=gk[:,:]        
    return V,A,g

@jit(nopython=True,cache=True)
def reverse_sweep(phis:np.ndarray,SMs:np.ndarray,m:np.ndarray,V:np.ndarray,A:np.ndarray,g:np.ndarray,H:np.ndarray,COMs:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Carries out the forward sweep of the Recursive Newton Euler Algorithm
    
    Parameters
    ----------
    phis : numpy.ndarray of shape (6,6,6)
         array rigid body transformation matrices for frames 1 to 6
    SMs : list
         list of 6 link spatial inertias 
    m : list
         list of link masses
    V : numpy.ndarray of shape (6,6,1)
         array of link spatial velocities
    A : numpy.ndarray of shape (6,6,1)
         array of link spatial accelerations
    g : numpy.ndarray of shape (6,6,1)
         array of link spatial acceleration due to gravity
    H : numpy.ndarray
         Hinge Map Matrix
    COMs : numpy.ndarray of shape (3,6)
         array of Centres of Mass of the links

    Returns
    -------
    CG : numpy.ndarray of shape (6,1)
         Vector of Generalised Centripetal, Coriolis and Gravity forces
   
    &#34;&#34;&#34;
    
    CG=np.zeros((6,1))
    
    kbk=np.zeros((6,1))
    w=np.zeros((3,1))
    p=np.zeros((3,1))
    v=np.zeros((3,1))
    J=np.zeros((3,3))
    w[:]=V[5][0:3]
    J[:,:]=SMs[5][0:3,0:3]
    p[:,0]=COMs[:,5]
    v[:]=V[5][3:6]
    mk=m[5]
    kbk[0:3]=tilda(w) @ J @ w+mk*tilda(p) @ tilda(w) @ v
    kbk[3:6]=mk* tilda(w) @ tilda(w) @ p+mk*tilda(w) @ v
    Fk=SMs[5] @ (A[5]-g[5])+kbk
    CG[5]=H @ Fk
        
    for k in range(5,0,-1):
        w[:]=V[k-1][0:3]
        J[:,:]=SMs[k-1][0:3,0:3]
        p[:,0]=COMs[:,k-1]
        v[:]=V[k-1][3:6]
        mk=m[k-1]
        kbk[0:3]=tilda(w) @ J @ w +mk*tilda(p) @ tilda(w) @ v
        kbk[3:6]=mk*tilda(w) @ tilda(w) @ p+mk*tilda(w) @ v
        Fk[:,:]=phis[k] @ Fk+SMs[k-1] @ (A[k-1]-g[k-1])+kbk
        CG[k-1]=H @ Fk
               
    return CG

def get_DH(joints:np.ndarray,joint_names:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Gets the DH parameters (modified DH) from the Robot Description (URDF) loaded in the ROS parameter server
    
    Parameters
    ----------
    joints : numpy.ndarray
         array of 6 URDF.Joint objects
    joint_names : numpy.ndarray
         array of 6 Joint Names used to indicate the order in which the URDF.Joint objects exist in joints array

    Returns
    -------
     a : numpy.ndarray
         numpy array of shape (6,1) having the link length for links i=1 to 6
     alpha : numpy.ndarray
         numpy array of shape (6,1) having the link twist for links i=1 to 6
     d : numpy.ndarray
         numpy array of shape (6,1) having the joint offsets for joints i=1 to 6
     theta0 : numpy.ndarray
         numpy array of shape (6,1) having the nominal joint angle for joints i=1 to 6

    &#34;&#34;&#34;
    
    a=np.zeros((6,1))
    alpha=np.zeros((6,1))
    d=np.zeros((6,1))
    theta0=np.zeros((6,1))
    
    for i in range(1,7):
        joint_name=&#34;J&#34;+str(i)
        joint=joints[joint_names==joint_name][0]
        #these are the xyz and rpy from the joint tag. You can derive the used formulas by equating 
        #the transformation matrix from DH parameters with the transformation matrix from xyz-rpy
        x=joint.origin.xyz[0]
        y=joint.origin.xyz[1]
        z=joint.origin.xyz[2]
        roll=joint.origin.rpy[0]
        pitch=joint.origin.rpy[1]
        yaw=joint.origin.rpy[2]
        if i&gt;1:
            a[i-2,0]=x
            alpha[i-2,0]=-np.arctan2(np.cos(roll)*np.sin(pitch)*np.sin(yaw) - np.cos(yaw)*np.sin(roll),np.cos(pitch)*np.cos(roll))
            a_=a[i-2,0]
            alpha_=alpha[i-2,0]
        else:
            a_=a0
            alpha_=alpha0
        if alpha_!=0:
            d[i-1,0]=-y/np.sin(alpha_)
        else:
            d[i-1,0]=z/np.cos(alpha_)
        theta0[i-1,0]=-np.arctan2(np.cos(yaw)*np.sin(pitch)*np.sin(roll) - np.cos(roll)*np.sin(yaw),np.cos(pitch)*np.cos(yaw))
    
    return a,alpha,d,theta0

@jit(nopython=True,cache=True)
def euler2omega_jacobian(alpha:float,beta:float,gamma:float)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles

    Parameters
    ----------
    alpha : float
         first angle in a ZYZ Euler Angle notation
    beta : float
         second angle in a ZYZ Euler Angle notation
    gamma : float
         third angle in a ZYZ Euler Angle notation

    Returns
    -------
    Te : numpy.ndarray of shape (3,3)
         3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles

    &#34;&#34;&#34;
    
    Te = np.array([[0.0, -np.sin(alpha), np.cos(alpha)*np.sin(beta)],
                     [0.0, np.cos(alpha), np.sin(alpha)*np.sin(beta)],
                     [1.0, 0.0, np.cos(beta)]])
    return Te

@jit(nopython=True,cache=True)
def geometric2analytic_jacobian(euler:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 6x6 matrix which needs to be post multiplied by the Geometric Jacobian 
    for converting it into Analytical Jacobian for use with ZYZ Euler Angles

    Parameters
    ----------
    euler : np.ndarray of shape (3,1)
         array of euler angles

    Returns
    -------
    Ta_inv : numpy.ndarray of shape (6,6)
         6x6 matrix which needs to be post multiplied by the 6x6 Geometric Jacobian 
        of a single side for converting it into Analytical Jacobian for use with ZYZ Euler Angles

    &#34;&#34;&#34;
    
    alpha=euler[0,0]
    beta=euler[1,0]
    gamma=euler[2,0]
    Te=euler2omega_jacobian(alpha,beta,gamma)
    Te_inv=inv(Te)
    Ta_inv=np.eye(6)
    Ta_inv[0:3,0:3]=Te_inv
    return Ta_inv

@jit(nopython=True,cache=True)
def geometric_jacobian(cphis:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;returns the 6x6 Geometric Jacobian.

    Parameters
    ----------
    cphis : np.ndarray of shape (6,6,6)
         array of 6 6x6 Cummulative Rigid Body Transformation Matrices

    Returns
    -------
    J : numpy.ndarray of shape 6x6
         6x6 Geometric Jacobian.
         
    J_ : numpy.ndarray of shape 6x6
         6X6 Jacobian for the velocities in the last joint frame
         expressed in itself. Useful for computing derivative later.
    
    R06 : numpy.ndarray of shape 6x6
         Rotational Rigid body transformation matrix from frame #6 to frame #0

    &#34;&#34;&#34;
    
    J_=np.zeros((6,6))
    R=cphis[0,0:3,0:3]
    R06=np.zeros((6,6))
    R06[0:3,0:3]=R06[3:6,3:6]=R
    for i in range(1,6):
        J_[:,i-1]=(cphis[i].T @ H.T).ravel()
    J_[:,5]=(H.T).ravel()
    J=R06 @ phi6_ef.T @ J_ 
    return J,J_,R06
    
def joint2task(theta:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Converts Joint Space Coordinates to Task Space Coordinates for the ZYZ Euler Angle Representation of Orientation
    
    Parameters
    ----------
    theta : numpy.ndarray of shape (6,1)
         Joint Space Coordinate

    Returns
    -------
    X : numpy.ndarray of shape (6,1)
         Task Space Coordinate
    &#34;&#34;&#34;
    
    X=np.zeros((6,1))
    phis=get_phi(alpha,a,theta0,theta,d,a0,alpha0)[0]
    cphis=get_cummulative_phi(phis)
    ef=np.matmul(cphis[0,:,:],phi6_ef)
    X[0:3]=np.array(euler_from_matrix(ef[0:3,0:3],&#39;rzyz&#39;)).reshape((3,1))
    X[3:6]=pos_from_phi(ef)
    
    return X

@jit(nopython=True,cache=True)
def dphis_dq(theta:np.ndarray,phis_l:np.ndarray,n:int=6)-&gt;np.ndarray:
    &#34;&#34;&#34;returns 3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable

    Parameters
    ----------
    theta : np.ndarray of shape (n,1)
        vector of current joint variables
    phis_l : np.ndarray of shape (n,6,6)
        3D array of stacked link rigid body transformation matrices
    n : int, optional
        Number of DOF. The default is 6.

    Returns
    -------
    dphis : np.ndarray of shape (n,6,6)
        3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable

    &#34;&#34;&#34;
    
    dphis=np.zeros((n,6,6))
    for j in range(1,n+1):
        dphis[j-1]=phis_l[j-1] @ dphih_dq(j,theta[j-1,0])
    return dphis


@jit(nopython=True,cache=True)
def dphih_dq(j:int,q:float)-&gt;np.ndarray:
    &#34;&#34;&#34;returns derivative of hinge rigid body transformation matrix wrt the respective joint angle.

    Parameters
    ----------
    j : int
        joint variable index.
    q : float
        joint variable value.

    Returns
    -------
    dphi_h : np.ndarray of shape (6,6)
        derivative of hinge rigid body transformation matrix wrt the respective joint angle.
    &#34;&#34;&#34;   
    
    theta=q+theta0[j-1,0]
    R=np.array([[-np.sin(theta),-np.cos(theta),0.0],
                [np.cos(theta),-np.sin(theta),0.0],
                [0.0,0.0,0.0]])
    dphi_h=np.zeros((6,6))
    dphi_h[0:3,0:3]=dphi_h[3:6,3:6]=R
    return dphi_h

@jit(nopython=True,cache=True)
def dTe(euler:np.ndarray,deuler:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of Te

    Parameters
    ----------
    euler : np.ndarray of shape (3,1)
        euler angles.
    deuler : np.ndarray of shape (3,1)
        euler angle rates.

    Returns
    -------
    DTE : np.ndarray of shape (6,6)
        time derivative of Te

    &#34;&#34;&#34;
    
    alpha=euler[0,0]
    beta=euler[1,0]
    gamma=euler[2,0]
    dalpha=deuler[0,0]
    dbeta=deuler[1,0]
    dgamma=deuler[2,0]
    dte=np.array([[0.0, -np.cos(alpha)*dalpha, np.cos(alpha)*np.cos(beta)*dbeta-np.sin(alpha)*np.sin(beta)*dalpha],
                  [0.0, -np.sin(alpha)*dalpha, np.cos(alpha)*np.sin(beta)*dalpha+np.sin(alpha)*np.cos(beta)*dbeta],
                  [0.0, 0.0, -np.sin(beta)*dbeta]])
    DTE=np.zeros((6,6))
    DTE[0:3,0:3]=dte
    return DTE

@jit(nopython=True)
def dJi_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int,i:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of i&#39;th column of J_hat

    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        Number of DOF.
    i : int
        column number.

    Returns
    -------
    dj_ : np.ndarray
        time derivative of the i&#39;th column of J_hat

    &#34;&#34;&#34;    
    phi_p=np.zeros((n-i,1,6))
    phi_p[0]=H
    phi_s=np.zeros((n-i,6,6))
    phi_s[0:-1]=cphis[i+1:n]
    phi_s[-1]=np.eye(6)
    for k in range(i+1,n):
        phi_p[k-i]=phi_p[k-i-1] @ phis[k-1]
    dj_=np.zeros((6,1))
    for k in range(i,n):
        dj_+=dq[k,0] * (phi_p[k-i] @ dphis[k] @ phi_s[k-i])
    return dj_.ravel()

# def dJi_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int,i:int)-&gt;np.ndarray:
#     &#34;&#34;&#34;returns time derivative of i&#39;th column of J_hat

#     Parameters
#     ----------
#     phis : np.ndarray of shape (n,6,6)
#         3D array of stacked rigid body transformation matrices
#     dphis : np.ndarray of shape (n,6,6)
#         3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable
#     cphis : np.ndarray of shape (n,6,6)
#         3D array of stacked cummulative rigid body transformation matrices
#     dq : np.ndarray of shape (n,1)
#         array of current joint velocities
#     n : int
#         Number of DOF.
#     i : int
#         column number.

#     Returns
#     -------
#     dj_ : np.ndarray
#         time derivative of the i&#39;th column of J_hat

#     &#34;&#34;&#34;
    
#     phi_p=np.zeros((n-i,1,6))
#     phi_p[0]=H
#     phi_s=np.zeros((n-i,6,6))
#     phi_s[0:-1]=cphis[i+1:n]
#     phi_s[-1]=np.eye(6)
#     for k in range(i+1,n):
#         phi_p[k-i]=phi_p[k-i-1] @ phis[k-1]
#     dj_=np.sum(dq[i:n] *(phi_p @ dphis[i:n] @ phi_s)[:,0,:],axis=0)
#     return dj_

@jit(nopython=True,cache=True)
def dJ_dt_(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of J_hat
    
    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dJ_ : np.ndarray
        time derivative of J_hat.

    &#34;&#34;&#34;
    
    dJ_=np.zeros((6,n))
    for i in range(1,n):
        dJ_[:,i-1]=dJi_dt(phis,dphis,cphis,dq,n,i)
    return dJ_

@jit(nopython=True,cache=True)
def dR_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of R0n

    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt corresponding joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dR : np.ndarray
        time derivative of R0n.

    &#34;&#34;&#34;
    
    R_p=np.zeros((n,3,3))
    R_p[0]=np.eye(3)
    for k in range(1,n):
        R_p[k]=R_p[k-1] @ phis[k-1,0:3,0:3]
    R_s=np.zeros((n,3,3))
    R_s[0:-1]=cphis[1:n,0:3,0:3]
    R_s[-1]=np.eye(3)
    dr=np.zeros((3,3))
    for i in range(n):
        dr+= dq[i,0] * (R_p[i] @ dphis[i,0:3,0:3] @ R_s[i])
    dR=np.zeros((6,6))
    dR[0:3,0:3]=dR[3:6,3:6]=dr
    return dR

# def dR_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
#     &#34;&#34;&#34;returns time derivative of R0n

#     Parameters
#     ----------
#     phis : np.ndarray of shape (n,6,6)
#         3D array of stacked rigid body transformation matrices
#     dphis : np.ndarray of shape (n,6,6)
#         3D array of stacked derivative of rigid body transformation matrices wrt corresponding joint variable
#     cphis : np.ndarray of shape (n,6,6)
#         3D array of stacked cummulative rigid body transformation matrices
#     dq : np.ndarray of shape (n,1)
#         array of current joint velocities
#     n : int
#         number of DOF.

#     Returns
#     -------
#     dR : np.ndarray
#         time derivative of R0n.

#     &#34;&#34;&#34;
    
#     R_p=np.zeros((n,3,3))
#     R_p[0]=np.eye(3)
#     for k in range(1,n):
#         R_p[k]=R_p[k-1] @ phis[k-1,0:3,0:3]
#     R_s=np.zeros((n,3,3))
#     R_s[0:-1]=cphis[1:n,0:3,0:3]
#     R_s[-1]=np.eye(3)
#     dr= np.sum(dq * (R_p @ dphis[:,0:3,0:3] @ R_s).reshape((n,9)), axis=0).reshape(3,3)
#     dR=np.zeros((6,6))
#     dR[0:3,0:3]=dR[3:6,3:6]=dr
#     return dR

@jit(nopython=True,cache=True)
def dJ_dt(J_:np.ndarray,R06:np.ndarray,phis:np.ndarray,phis_l:np.ndarray,cphis:np.ndarray,q:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of geometric jacobian

    Parameters
    ----------
    J_ : np.ndarray of shape (6,n)
        J_hat
    R06 : np.ndarray of shape (6,6)
        Spatial rotation from #0 to #n
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    phis_l : np.ndarray of shape (n,6,6)
        3D array of stacked link rigid body transformation matrices
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    q : np.ndarray of shape (n,1)
        array of current joint position
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dJ : np.ndarray
        time derivative of geometric jacobian

    &#34;&#34;&#34;
    
    dphis=dphis_dq(q,phis_l,n)
    dJ_=dJ_dt_(phis,dphis,cphis,dq,n)
    dR=dR_dt(phis,dphis,cphis,dq,n)
    dJ=dR @ phi6_ef.T @ J_ + R06 @ phi6_ef.T @ dJ_
    return dJ

@jit(nopython=True,cache=True)
def R2Euler(R:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;
    Converts Rotation matrix to ZYZ Euler angle representation

    Parameters
    ----------
    R : np.ndarray
        Rotation matrix.

    Returns
    -------
    np.ndarray of shape (3,1)
        Vector of euler angles(ZYZ current frame).

    &#34;&#34;&#34;
    beta=np.arctan2(-np.sqrt(1-R[2,2]**2),R[2,2])
    alpha=np.arctan2(-R[1,2],-R[0,2])
    gamma=np.arctan2(-R[2,1],R[2,0])
    return np.array([[alpha,beta,gamma]]).T

@jit(nopython=True,cache=True)
def regularize(A,cond):
    &#34;&#34;&#34;
    regularizes input matrix A using a modified truncated SVD regularization using
    cond as the threshold condition number

    Parameters
    ----------
    A : numpy.ndarray
         input matrix
    cond : float
         threshold condition number

    Returns
    -------
    A_ : numpy.ndarray
         regularized matrix
    A_pinv: numpy.ndarray
        pseudo inverse of regularized matrix

    &#34;&#34;&#34;
    U,S,Vt=np.linalg.svd(A)

    S=S[S[0]/S&lt;cond]

    S_=np.diag(S)
    n=len(S)
    A_=U[:,0:n] @ S_ @ Vt[0:n,:]#regularized matrix

    S1=1/S
    S1_=np.diag(S1)
    A_pinv=Vt[0:n,:].T @ S1_ @ U[:,0:n].T
    return A_,A_pinv

@jit(nopython=True,cache=True)
def state_difference(Xg,Xs):
    &#34;&#34;&#34;
    The function which gives the difference between task space coordinates
    Xg and Xs as per the Euler Angle based scheme.

    Parameters
    ----------
    Xg : numpy.ndarray
         goal task space coordinate/desired task space coordinate
    Xs : numpy.ndarray
         start task space coordinate/current task space coordinate

    Returns
    -------
    Xd : numpy.ndarray
         difference between task space coordinates Xg and Xs as per the control scheme.

    &#34;&#34;&#34;
    Xd=np.zeros(Xg.shape)
    for i in range(3):
        diff=Xg[i,0]-Xs[i,0]
        if abs(diff)&gt;pi:
            Xd[i,0]=-np.sign(diff)*(2*pi-abs(diff))
        else:
            Xd[i,0]=diff
    Xd[3:6]=Xg[3:6]-Xs[3:6]
    # Xd=Xg-Xs
    # Xde=Xd[0:3]
    # #converting angles greater than pi to equivalent negative angle
    # #done so that the difference indicates the shortest possible path
    # idx=np.abs(Xde)&gt;pi
    # Xde[idx]=-np.sign(Xde[idx])*(2*pi-np.abs(Xde[idx]))
    # Xd[0:3,0]=Xde[0:3,0]
    return Xd

#initializing kinematic parameters of the Manipulator  
print(&#34;Initializing Kinematic properties of the Manipulator&#34;) 
robot = URDF.from_parameter_server() #getting robot description from ROS parameter server
link_names=np.array([l.name for l in robot.links]) #list of link names
links=np.array(robot.links) #list of URDF.Link
joint_names=np.array([j.name for j in robot.joints]) #list of joint names
joints=np.array(robot.joints) #list of URDF.Joint

H=np.array([[0,0,1,0,0,0]],dtype=np.float64) #Hinge Map Matrix
&#34;&#34;&#34;Hinge Map Matrix for a revolute joint&#34;&#34;&#34;

a0=0 #link length for base link
&#34;&#34;&#34;Link length for base link&#34;&#34;&#34;

alpha0=0 #link twist for base link
&#34;&#34;&#34;Link twist for base link&#34;&#34;&#34;

a=np.zeros((6,1))
&#34;&#34;&#34;array of DH parameters a&#34;&#34;&#34;
alpha=np.zeros((6,1))
&#34;&#34;&#34;array of DH parameters alpha&#34;&#34;&#34;
d=np.zeros((6,1))
&#34;&#34;&#34;array of DH parameters d&#34;&#34;&#34;
theta0=np.zeros((6,1))
&#34;&#34;&#34;array of nominal joint angles&#34;&#34;&#34;
a[:,:],alpha[:,:],d[:,:],theta0[:,:]=get_DH(joints,joint_names)#get DH parameters

#rigid body transformation matrices from #6 to end effector frame
phi6_ef=np.zeros((6,6),dtype=np.float64)
&#34;&#34;&#34;rigid body transformation matrices from #6 to end effector frame&#34;&#34;&#34;

phi6_ef[0:3,3:6]=tilda(np.array([[0,0,0.25722535]]).T)
phi6_ef[0:3,0:3]=phi6_ef[3:6,3:6]=np.eye(3)


#initializing mass-inertia properties of the Manipulator
print(&#34;Initializing Mass-Inertia properties of the Manipulator&#34;)
m=np.array(6*[0],dtype=np.float64) #list of link masses
&#34;&#34;&#34;list of link masses&#34;&#34;&#34;
COMs=np.zeros((3,6),dtype=np.float64) #list of link centre of mass
&#34;&#34;&#34;array of link centre of masses&#34;&#34;&#34;
IMs=6*[0] #list of Inertia Tensor
&#34;&#34;&#34;list of link rotational inertias&#34;&#34;&#34;

for i in range(1,7):
    m[i-1],COMs[:,i-1],IMs[i-1]=create_IM(links[link_names==&#39;L&#39;+str(i)])

SMs=get_SM(m,COMs,IMs)#spatial inertias
&#34;&#34;&#34;list of link spatial inertias&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="src.control_func.COMs"><code class="name">var <span class="ident">COMs</span></code></dt>
<dd>
<div class="desc"><p>array of link centre of masses</p></div>
</dd>
<dt id="src.control_func.H"><code class="name">var <span class="ident">H</span></code></dt>
<dd>
<div class="desc"><p>Hinge Map Matrix for a revolute joint</p></div>
</dd>
<dt id="src.control_func.IMs"><code class="name">var <span class="ident">IMs</span></code></dt>
<dd>
<div class="desc"><p>list of link rotational inertias</p></div>
</dd>
<dt id="src.control_func.SMs"><code class="name">var <span class="ident">SMs</span></code></dt>
<dd>
<div class="desc"><p>list of link spatial inertias</p></div>
</dd>
<dt id="src.control_func.a"><code class="name">var <span class="ident">a</span></code></dt>
<dd>
<div class="desc"><p>array of DH parameters a</p></div>
</dd>
<dt id="src.control_func.a0"><code class="name">var <span class="ident">a0</span></code></dt>
<dd>
<div class="desc"><p>Link length for base link</p></div>
</dd>
<dt id="src.control_func.alpha"><code class="name">var <span class="ident">alpha</span></code></dt>
<dd>
<div class="desc"><p>array of DH parameters alpha</p></div>
</dd>
<dt id="src.control_func.alpha0"><code class="name">var <span class="ident">alpha0</span></code></dt>
<dd>
<div class="desc"><p>Link twist for base link</p></div>
</dd>
<dt id="src.control_func.d"><code class="name">var <span class="ident">d</span></code></dt>
<dd>
<div class="desc"><p>array of DH parameters d</p></div>
</dd>
<dt id="src.control_func.m"><code class="name">var <span class="ident">m</span></code></dt>
<dd>
<div class="desc"><p>list of link masses</p></div>
</dd>
<dt id="src.control_func.phi6_ef"><code class="name">var <span class="ident">phi6_ef</span></code></dt>
<dd>
<div class="desc"><p>rigid body transformation matrices from #6 to end effector frame</p></div>
</dd>
<dt id="src.control_func.theta0"><code class="name">var <span class="ident">theta0</span></code></dt>
<dd>
<div class="desc"><p>array of nominal joint angles</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.control_func.R2Euler"><code class="name flex">
<span>def <span class="ident">R2Euler</span></span>(<span>R:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Rotation matrix to ZYZ Euler angle representation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Rotation matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>Vector of euler angles(ZYZ current frame).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def R2Euler(R:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;
    Converts Rotation matrix to ZYZ Euler angle representation

    Parameters
    ----------
    R : np.ndarray
        Rotation matrix.

    Returns
    -------
    np.ndarray of shape (3,1)
        Vector of euler angles(ZYZ current frame).

    &#34;&#34;&#34;
    beta=np.arctan2(-np.sqrt(1-R[2,2]**2),R[2,2])
    alpha=np.arctan2(-R[1,2],-R[0,2])
    gamma=np.arctan2(-R[2,1],R[2,0])
    return np.array([[alpha,beta,gamma]]).T</code></pre>
</details>
</dd>
<dt id="src.control_func.Rx"><code class="name flex">
<span>def <span class="ident">Rx</span></span>(<span>theta:Â numpy.float64) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns rotation matrix for a rotation about x axis by theta radians</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>angle in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>3x3 Rotation Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def Rx(theta:np.float64)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about x axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         3x3 Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[1.0,0.0,0.0],
                [0.0,np.cos(theta),-np.sin(theta)],
                [0.0,np.sin(theta),np.cos(theta)]])
    return R</code></pre>
</details>
</dd>
<dt id="src.control_func.Ry"><code class="name flex">
<span>def <span class="ident">Ry</span></span>(<span>theta:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns rotation matrix for a rotation about y axis by theta radians</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>angle in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>Rotation Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def Ry(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about y axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[np.cos(theta),0.0,np.sin(theta)],
                [0.0,1.0,0.0],
                [-np.sin(theta),0.0,np.cos(theta)]])
    return R</code></pre>
</details>
</dd>
<dt id="src.control_func.Rz"><code class="name flex">
<span>def <span class="ident">Rz</span></span>(<span>theta:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns rotation matrix for a rotation about z axis by theta radians</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>angle in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>Rotation Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def Rz(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns rotation matrix for a rotation about z axis by theta radians

    Parameters
    ----------
    theta : float
         angle in radians 

    Returns
    -------
    R : numpy.ndarray of shape (3,3)
         Rotation Matrix

    &#34;&#34;&#34;
    
    R=np.array([[np.cos(theta),-np.sin(theta),0.0],
                [np.sin(theta),np.cos(theta),0.0],
                [0.0,0.0,1.0]])
    return R</code></pre>
</details>
</dd>
<dt id="src.control_func.compute_D"><code class="name flex">
<span>def <span class="ident">compute_D</span></span>(<span>SMs:Â numpy.ndarray, phis:Â numpy.ndarray, H:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns the 6x6 Joint Space Inertia Matrix D computed using the Composite Rigid Body Algorithm</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>SMs</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>np.ndarray of shape (6,6,6) of spatial inertias</dd>
<dt><strong><code>phis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of 6 rigid body transformation matrices for frames 1 to 6</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Hinge Map Matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>D</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>6x6 Joint Space Inertia Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def compute_D(SMs:np.ndarray, phis:np.ndarray,H:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 6x6 Joint Space Inertia Matrix D computed using the Composite Rigid Body Algorithm

    Parameters
    ----------
    SMs : np.ndarray
          np.ndarray of shape (6,6,6) of spatial inertias
    phis : numpy.ndarray of shape (6,6,6)
          array of 6 rigid body transformation matrices for frames 1 to 6
    H : numpy.ndarray
          Hinge Map Matrix

    Returns
    -------
    D : numpy.ndarray of shape (6,6)
          6x6 Joint Space Inertia Matrix

    &#34;&#34;&#34;
    
    D=np.zeros((6,6))
    R=np.zeros((6,6))
    F=np.zeros((6,1))
    R[:,:]=SMs[5]
    F[:,:]=R @ H.T
    D[5,5]=(H @ F)[0,0]
    for j in range(4,-1,-1):
        F[:,:]=phis[j+1] @ F
        D[j,5]=D[5,j]=(H @ F)[0,0]
            
    for k in range(4,-1,-1):
        R[:,:]=SMs[k]+phis[k+1] @ R @ phis[k+1].T
        F[:,:]=R @ H.T
        D[k,k]=(H @ F)[0,0]
        for j in np.arange(k-1,-1,-1):
            F[:,:]=phis[j+1] @ F
            D[j,k]=D[k,j]=(H @ F)[0,0]            
    return D</code></pre>
</details>
</dd>
<dt id="src.control_func.create_IM"><code class="name flex">
<span>def <span class="ident">create_IM</span></span>(<span>link) â€‘>Â Tuple[float,Â numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the mass-inertia properties of the link from the Robot Description (URDF) loaded in the ROS parameter server
returns a tuple of the form (m,COM,I)
where m is the mass of the link
COM is the coordinates of the Centre of Mass of the link in terms of the link frame
I is the inertia tensor w.r.t the link frames</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>link</code></strong> :&ensp;<code>URDF.Link</code></dt>
<dd>urdf.link object corresponding to the link whose mass-inertia properties need to be extracted</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>Mass of the link</dd>
<dt><strong><code>COM</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,)</code></dt>
<dd>Coordinates of Centre of Mass of the links in terms of the link frame</dd>
<dt><strong><code>I</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>Inertia Tensor in terms of the link frame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_IM(link)-&gt;Tuple[float,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Gets the mass-inertia properties of the link from the Robot Description (URDF) loaded in the ROS parameter server
    returns a tuple of the form (m,COM,I)
    where m is the mass of the link
    COM is the coordinates of the Centre of Mass of the link in terms of the link frame
    I is the inertia tensor w.r.t the link frames
    
    Parameters
    ----------
    link : URDF.Link
         urdf.link object corresponding to the link whose mass-inertia properties need to be extracted

    Returns
    -------
    m : float
         Mass of the link
    COM : numpy.ndarray of shape (3,)
         Coordinates of Centre of Mass of the links in terms of the link frame
    I : numpy.ndarray of shape (3,3)
         Inertia Tensor in terms of the link frame

    &#34;&#34;&#34;
    
    link=link[0]
    ixx=link.inertial.inertia.ixx
    ixy=link.inertial.inertia.ixy
    ixz=link.inertial.inertia.ixz
    iyy=link.inertial.inertia.iyy
    iyz=link.inertial.inertia.iyz
    izz=link.inertial.inertia.izz
    I=np.array([[ixx,ixy,ixz],
                [ixy,iyy,iyz],
                [ixz,iyz,izz]],dtype=np.float64)
    
    m=link.inertial.mass
    
    COM=np.array(link.inertial.origin.xyz,dtype=np.float64)

    COM=COM.reshape((3,1))

    It1=m*np.matmul(COM.T,COM)*np.eye(3,dtype=np.float64)
    It2=-m*np.matmul(COM,COM.T)

    I=I+1*It1+1*It2
    
    return m,COM.flatten(),I</code></pre>
</details>
</dd>
<dt id="src.control_func.dJ_dt"><code class="name flex">
<span>def <span class="ident">dJ_dt</span></span>(<span>J_:Â numpy.ndarray, R06:Â numpy.ndarray, phis:Â numpy.ndarray, phis_l:Â numpy.ndarray, cphis:Â numpy.ndarray, q:Â numpy.ndarray, dq:Â numpy.ndarray, n:Â int) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns time derivative of geometric jacobian</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>J_</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,n)</code></dt>
<dd>J_hat</dd>
<dt><strong><code>R06</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Spatial rotation from #0 to #n</dd>
<dt><strong><code>phis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked rigid body transformation matrices</dd>
<dt><strong><code>phis_l</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked link rigid body transformation matrices</dd>
<dt><strong><code>cphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked cummulative rigid body transformation matrices</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>array of current joint position</dd>
<dt><strong><code>dq</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>array of current joint velocities</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of DOF.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dJ</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>time derivative of geometric jacobian</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dJ_dt(J_:np.ndarray,R06:np.ndarray,phis:np.ndarray,phis_l:np.ndarray,cphis:np.ndarray,q:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of geometric jacobian

    Parameters
    ----------
    J_ : np.ndarray of shape (6,n)
        J_hat
    R06 : np.ndarray of shape (6,6)
        Spatial rotation from #0 to #n
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    phis_l : np.ndarray of shape (n,6,6)
        3D array of stacked link rigid body transformation matrices
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    q : np.ndarray of shape (n,1)
        array of current joint position
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dJ : np.ndarray
        time derivative of geometric jacobian

    &#34;&#34;&#34;
    
    dphis=dphis_dq(q,phis_l,n)
    dJ_=dJ_dt_(phis,dphis,cphis,dq,n)
    dR=dR_dt(phis,dphis,cphis,dq,n)
    dJ=dR @ phi6_ef.T @ J_ + R06 @ phi6_ef.T @ dJ_
    return dJ</code></pre>
</details>
</dd>
<dt id="src.control_func.dJ_dt_"><code class="name flex">
<span>def <span class="ident">dJ_dt_</span></span>(<span>phis:Â numpy.ndarray, dphis:Â numpy.ndarray, cphis:Â numpy.ndarray, dq:Â numpy.ndarray, n:Â int) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns time derivative of J_hat</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked rigid body transformation matrices</dd>
<dt><strong><code>dphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable</dd>
<dt><strong><code>cphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked cummulative rigid body transformation matrices</dd>
<dt><strong><code>dq</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>array of current joint velocities</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of DOF.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dJ_</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>time derivative of J_hat.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dJ_dt_(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of J_hat
    
    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dJ_ : np.ndarray
        time derivative of J_hat.

    &#34;&#34;&#34;
    
    dJ_=np.zeros((6,n))
    for i in range(1,n):
        dJ_[:,i-1]=dJi_dt(phis,dphis,cphis,dq,n,i)
    return dJ_</code></pre>
</details>
</dd>
<dt id="src.control_func.dJi_dt"><code class="name flex">
<span>def <span class="ident">dJi_dt</span></span>(<span>phis:Â numpy.ndarray, dphis:Â numpy.ndarray, cphis:Â numpy.ndarray, dq:Â numpy.ndarray, n:Â int, i:Â int) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns time derivative of i'th column of J_hat</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked rigid body transformation matrices</dd>
<dt><strong><code>dphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable</dd>
<dt><strong><code>cphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked cummulative rigid body transformation matrices</dd>
<dt><strong><code>dq</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>array of current joint velocities</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of DOF.</dd>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>column number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dj_</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>time derivative of the i'th column of J_hat</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True)
def dJi_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int,i:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of i&#39;th column of J_hat

    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt respective joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        Number of DOF.
    i : int
        column number.

    Returns
    -------
    dj_ : np.ndarray
        time derivative of the i&#39;th column of J_hat

    &#34;&#34;&#34;    
    phi_p=np.zeros((n-i,1,6))
    phi_p[0]=H
    phi_s=np.zeros((n-i,6,6))
    phi_s[0:-1]=cphis[i+1:n]
    phi_s[-1]=np.eye(6)
    for k in range(i+1,n):
        phi_p[k-i]=phi_p[k-i-1] @ phis[k-1]
    dj_=np.zeros((6,1))
    for k in range(i,n):
        dj_+=dq[k,0] * (phi_p[k-i] @ dphis[k] @ phi_s[k-i])
    return dj_.ravel()</code></pre>
</details>
</dd>
<dt id="src.control_func.dR_dt"><code class="name flex">
<span>def <span class="ident">dR_dt</span></span>(<span>phis:Â numpy.ndarray, dphis:Â numpy.ndarray, cphis:Â numpy.ndarray, dq:Â numpy.ndarray, n:Â int) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns time derivative of R0n</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked rigid body transformation matrices</dd>
<dt><strong><code>dphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked derivative of rigid body transformation matrices wrt corresponding joint variable</dd>
<dt><strong><code>cphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked cummulative rigid body transformation matrices</dd>
<dt><strong><code>dq</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>array of current joint velocities</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>number of DOF.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dR</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>time derivative of R0n.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dR_dt(phis:np.ndarray,dphis:np.ndarray,cphis:np.ndarray,dq:np.ndarray,n:int)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of R0n

    Parameters
    ----------
    phis : np.ndarray of shape (n,6,6)
        3D array of stacked rigid body transformation matrices
    dphis : np.ndarray of shape (n,6,6)
        3D array of stacked derivative of rigid body transformation matrices wrt corresponding joint variable
    cphis : np.ndarray of shape (n,6,6)
        3D array of stacked cummulative rigid body transformation matrices
    dq : np.ndarray of shape (n,1)
        array of current joint velocities
    n : int
        number of DOF.

    Returns
    -------
    dR : np.ndarray
        time derivative of R0n.

    &#34;&#34;&#34;
    
    R_p=np.zeros((n,3,3))
    R_p[0]=np.eye(3)
    for k in range(1,n):
        R_p[k]=R_p[k-1] @ phis[k-1,0:3,0:3]
    R_s=np.zeros((n,3,3))
    R_s[0:-1]=cphis[1:n,0:3,0:3]
    R_s[-1]=np.eye(3)
    dr=np.zeros((3,3))
    for i in range(n):
        dr+= dq[i,0] * (R_p[i] @ dphis[i,0:3,0:3] @ R_s[i])
    dR=np.zeros((6,6))
    dR[0:3,0:3]=dR[3:6,3:6]=dr
    return dR</code></pre>
</details>
</dd>
<dt id="src.control_func.dTe"><code class="name flex">
<span>def <span class="ident">dTe</span></span>(<span>euler:Â numpy.ndarray, deuler:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns time derivative of Te</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>euler</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>euler angles.</dd>
<dt><strong><code>deuler</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>euler angle rates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>DTE</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>time derivative of Te</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dTe(euler:np.ndarray,deuler:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns time derivative of Te

    Parameters
    ----------
    euler : np.ndarray of shape (3,1)
        euler angles.
    deuler : np.ndarray of shape (3,1)
        euler angle rates.

    Returns
    -------
    DTE : np.ndarray of shape (6,6)
        time derivative of Te

    &#34;&#34;&#34;
    
    alpha=euler[0,0]
    beta=euler[1,0]
    gamma=euler[2,0]
    dalpha=deuler[0,0]
    dbeta=deuler[1,0]
    dgamma=deuler[2,0]
    dte=np.array([[0.0, -np.cos(alpha)*dalpha, np.cos(alpha)*np.cos(beta)*dbeta-np.sin(alpha)*np.sin(beta)*dalpha],
                  [0.0, -np.sin(alpha)*dalpha, np.cos(alpha)*np.sin(beta)*dalpha+np.sin(alpha)*np.cos(beta)*dbeta],
                  [0.0, 0.0, -np.sin(beta)*dbeta]])
    DTE=np.zeros((6,6))
    DTE[0:3,0:3]=dte
    return DTE</code></pre>
</details>
</dd>
<dt id="src.control_func.dphih_dq"><code class="name flex">
<span>def <span class="ident">dphih_dq</span></span>(<span>j:Â int, q:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns derivative of hinge rigid body transformation matrix wrt the respective joint angle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>j</code></strong> :&ensp;<code>int</code></dt>
<dd>joint variable index.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code></dt>
<dd>joint variable value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dphi_h</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>derivative of hinge rigid body transformation matrix wrt the respective joint angle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dphih_dq(j:int,q:float)-&gt;np.ndarray:
    &#34;&#34;&#34;returns derivative of hinge rigid body transformation matrix wrt the respective joint angle.

    Parameters
    ----------
    j : int
        joint variable index.
    q : float
        joint variable value.

    Returns
    -------
    dphi_h : np.ndarray of shape (6,6)
        derivative of hinge rigid body transformation matrix wrt the respective joint angle.
    &#34;&#34;&#34;   
    
    theta=q+theta0[j-1,0]
    R=np.array([[-np.sin(theta),-np.cos(theta),0.0],
                [np.cos(theta),-np.sin(theta),0.0],
                [0.0,0.0,0.0]])
    dphi_h=np.zeros((6,6))
    dphi_h[0:3,0:3]=dphi_h[3:6,3:6]=R
    return dphi_h</code></pre>
</details>
</dd>
<dt id="src.control_func.dphis_dq"><code class="name flex">
<span>def <span class="ident">dphis_dq</span></span>(<span>theta:Â numpy.ndarray, phis_l:Â numpy.ndarray, n:Â intÂ =Â 6) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns 3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,1)</code></dt>
<dd>vector of current joint variables</dd>
<dt><strong><code>phis_l</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D array of stacked link rigid body transformation matrices</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of DOF. The default is 6.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (n,6,6)</code></dt>
<dd>3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def dphis_dq(theta:np.ndarray,phis_l:np.ndarray,n:int=6)-&gt;np.ndarray:
    &#34;&#34;&#34;returns 3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable

    Parameters
    ----------
    theta : np.ndarray of shape (n,1)
        vector of current joint variables
    phis_l : np.ndarray of shape (n,6,6)
        3D array of stacked link rigid body transformation matrices
    n : int, optional
        Number of DOF. The default is 6.

    Returns
    -------
    dphis : np.ndarray of shape (n,6,6)
        3D matrix of stacked derivative of rigid body transformation matrices wrt respective joint variable

    &#34;&#34;&#34;
    
    dphis=np.zeros((n,6,6))
    for j in range(1,n+1):
        dphis[j-1]=phis_l[j-1] @ dphih_dq(j,theta[j-1,0])
    return dphis</code></pre>
</details>
</dd>
<dt id="src.control_func.euler2omega_jacobian"><code class="name flex">
<span>def <span class="ident">euler2omega_jacobian</span></span>(<span>alpha:Â float, beta:Â float, gamma:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns the 3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>first angle in a ZYZ Euler Angle notation</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code></dt>
<dd>second angle in a ZYZ Euler Angle notation</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code></dt>
<dd>third angle in a ZYZ Euler Angle notation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Te</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def euler2omega_jacobian(alpha:float,beta:float,gamma:float)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles

    Parameters
    ----------
    alpha : float
         first angle in a ZYZ Euler Angle notation
    beta : float
         second angle in a ZYZ Euler Angle notation
    gamma : float
         third angle in a ZYZ Euler Angle notation

    Returns
    -------
    Te : numpy.ndarray of shape (3,3)
         3x3 Jacobian Matrix for converting angular velocities to Euler Angle Rates for the ZYZ Euler Angles

    &#34;&#34;&#34;
    
    Te = np.array([[0.0, -np.sin(alpha), np.cos(alpha)*np.sin(beta)],
                     [0.0, np.cos(alpha), np.sin(alpha)*np.sin(beta)],
                     [1.0, 0.0, np.cos(beta)]])
    return Te</code></pre>
</details>
</dd>
<dt id="src.control_func.forward_sweep"><code class="name flex">
<span>def <span class="ident">forward_sweep</span></span>(<span>theta0:Â numpy.ndarray, theta:Â numpy.ndarray, dtheta:Â numpy.ndarray, phis:Â numpy.ndarray, H:Â numpy.ndarray) â€‘>Â Tuple[numpy.ndarray,Â numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out the forward sweep of the Recursive Newton Euler Algorithm</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta0</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of initial joint angles at home position</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of additional joint angle applied from home position</dd>
<dt><strong><code>dtheta</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of joint velocities</dd>
<dt><strong><code>phis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array rigid body transformation matrices for frames 1 to 6</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Hinge Map Matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of 12 link spatial velocities</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of 12 link spatial accelerations</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of 12 link spatial acceleration due to gravity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def forward_sweep(theta0:np.ndarray,theta:np.ndarray,dtheta:np.ndarray,phis:np.ndarray,H:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Carries out the forward sweep of the Recursive Newton Euler Algorithm
    
    Parameters
    ----------
    theta0 : numpy.ndarray of shape (6,1)
         array of initial joint angles at home position
    theta : numpy.ndarray of shape (6,1)
         array of additional joint angle applied from home position
    dtheta : numpy.ndarray of shape (6,1)
         array of joint velocities
    phis : numpy.ndarray of shape (6,1)
         array rigid body transformation matrices for frames 1 to 6
    H : numpy.ndarray
         Hinge Map Matrix

    Returns
    -------
    V : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial velocities
    A : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial accelerations
    g : numpy.ndarray of shape (6,6,1)
         array of 12 link spatial acceleration due to gravity

    &#34;&#34;&#34;
    
    V=np.zeros((6,6,1))
    A=np.zeros((6,6,1))
    g=np.zeros((6,6,1))

    Vk=np.zeros((6,1))
    Ak=np.zeros((6,1))
    gk=np.zeros((6,1))
    gk[5]=-9.8
    kak=np.zeros((6,1))
    kwk=np.zeros((3,1))
    for k in np.arange(1,7,1):
        Vk[:,:]=phis[k-1].T @ Vk+H.T*dtheta[k-1]
        kwk[:,:]=(dtheta[k-1]*H.T)[0:3,:]
        kak[0:3,:]=-tilda(kwk) @ Vk[0:3]
        kak[3:6,:]=-tilda(kwk) @ Vk[3:6]
        Ak[:,:]=phis[k-1].T @ Ak+kak
        gk[:,:]=phis[k-1].T @ gk

        V[k-1,:,:]=Vk[:,:]
        A[k-1,:,:]=Ak[:,:]
        g[k-1,:,:]=gk[:,:]        
    return V,A,g</code></pre>
</details>
</dd>
<dt id="src.control_func.geometric2analytic_jacobian"><code class="name flex">
<span>def <span class="ident">geometric2analytic_jacobian</span></span>(<span>euler:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns the 6x6 matrix which needs to be post multiplied by the Geometric Jacobian
for converting it into Analytical Jacobian for use with ZYZ Euler Angles</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>euler</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>array of euler angles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Ta_inv</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>6x6 matrix which needs to be post multiplied by the 6x6 Geometric Jacobian
of a single side for converting it into Analytical Jacobian for use with ZYZ Euler Angles</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def geometric2analytic_jacobian(euler:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the 6x6 matrix which needs to be post multiplied by the Geometric Jacobian 
    for converting it into Analytical Jacobian for use with ZYZ Euler Angles

    Parameters
    ----------
    euler : np.ndarray of shape (3,1)
         array of euler angles

    Returns
    -------
    Ta_inv : numpy.ndarray of shape (6,6)
         6x6 matrix which needs to be post multiplied by the 6x6 Geometric Jacobian 
        of a single side for converting it into Analytical Jacobian for use with ZYZ Euler Angles

    &#34;&#34;&#34;
    
    alpha=euler[0,0]
    beta=euler[1,0]
    gamma=euler[2,0]
    Te=euler2omega_jacobian(alpha,beta,gamma)
    Te_inv=inv(Te)
    Ta_inv=np.eye(6)
    Ta_inv[0:3,0:3]=Te_inv
    return Ta_inv</code></pre>
</details>
</dd>
<dt id="src.control_func.geometric_jacobian"><code class="name flex">
<span>def <span class="ident">geometric_jacobian</span></span>(<span>cphis:Â numpy.ndarray) â€‘>Â Tuple[numpy.ndarray,Â numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>returns the 6x6 Geometric Jacobian.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cphis</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of 6 6x6 Cummulative Rigid Body Transformation Matrices</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>J</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape 6x6</code></dt>
<dd>6x6 Geometric Jacobian.</dd>
<dt><strong><code>J_</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape 6x6</code></dt>
<dd>6X6 Jacobian for the velocities in the last joint frame
expressed in itself. Useful for computing derivative later.</dd>
<dt><strong><code>R06</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape 6x6</code></dt>
<dd>Rotational Rigid body transformation matrix from frame #6 to frame #0</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def geometric_jacobian(cphis:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;returns the 6x6 Geometric Jacobian.

    Parameters
    ----------
    cphis : np.ndarray of shape (6,6,6)
         array of 6 6x6 Cummulative Rigid Body Transformation Matrices

    Returns
    -------
    J : numpy.ndarray of shape 6x6
         6x6 Geometric Jacobian.
         
    J_ : numpy.ndarray of shape 6x6
         6X6 Jacobian for the velocities in the last joint frame
         expressed in itself. Useful for computing derivative later.
    
    R06 : numpy.ndarray of shape 6x6
         Rotational Rigid body transformation matrix from frame #6 to frame #0

    &#34;&#34;&#34;
    
    J_=np.zeros((6,6))
    R=cphis[0,0:3,0:3]
    R06=np.zeros((6,6))
    R06[0:3,0:3]=R06[3:6,3:6]=R
    for i in range(1,6):
        J_[:,i-1]=(cphis[i].T @ H.T).ravel()
    J_[:,5]=(H.T).ravel()
    J=R06 @ phi6_ef.T @ J_ 
    return J,J_,R06</code></pre>
</details>
</dd>
<dt id="src.control_func.get_DH"><code class="name flex">
<span>def <span class="ident">get_DH</span></span>(<span>joints:Â numpy.ndarray, joint_names:Â numpy.ndarray) â€‘>Â Tuple[numpy.ndarray,Â numpy.ndarray,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the DH parameters (modified DH) from the Robot Description (URDF) loaded in the ROS parameter server</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>joints</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>array of 6 URDF.Joint objects</dd>
<dt><strong><code>joint_names</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>array of 6 Joint Names used to indicate the order in which the URDF.Joint objects exist in joints array</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a : numpy.ndarray
numpy array of shape (6,1) having the link length for links i=1 to 6
alpha : numpy.ndarray
numpy array of shape (6,1) having the link twist for links i=1 to 6
d : numpy.ndarray
numpy array of shape (6,1) having the joint offsets for joints i=1 to 6
theta0 : numpy.ndarray
numpy array of shape (6,1) having the nominal joint angle for joints i=1 to 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_DH(joints:np.ndarray,joint_names:np.ndarray)-&gt;Tuple[np.ndarray,np.ndarray,np.ndarray]:
    &#34;&#34;&#34;Gets the DH parameters (modified DH) from the Robot Description (URDF) loaded in the ROS parameter server
    
    Parameters
    ----------
    joints : numpy.ndarray
         array of 6 URDF.Joint objects
    joint_names : numpy.ndarray
         array of 6 Joint Names used to indicate the order in which the URDF.Joint objects exist in joints array

    Returns
    -------
     a : numpy.ndarray
         numpy array of shape (6,1) having the link length for links i=1 to 6
     alpha : numpy.ndarray
         numpy array of shape (6,1) having the link twist for links i=1 to 6
     d : numpy.ndarray
         numpy array of shape (6,1) having the joint offsets for joints i=1 to 6
     theta0 : numpy.ndarray
         numpy array of shape (6,1) having the nominal joint angle for joints i=1 to 6

    &#34;&#34;&#34;
    
    a=np.zeros((6,1))
    alpha=np.zeros((6,1))
    d=np.zeros((6,1))
    theta0=np.zeros((6,1))
    
    for i in range(1,7):
        joint_name=&#34;J&#34;+str(i)
        joint=joints[joint_names==joint_name][0]
        #these are the xyz and rpy from the joint tag. You can derive the used formulas by equating 
        #the transformation matrix from DH parameters with the transformation matrix from xyz-rpy
        x=joint.origin.xyz[0]
        y=joint.origin.xyz[1]
        z=joint.origin.xyz[2]
        roll=joint.origin.rpy[0]
        pitch=joint.origin.rpy[1]
        yaw=joint.origin.rpy[2]
        if i&gt;1:
            a[i-2,0]=x
            alpha[i-2,0]=-np.arctan2(np.cos(roll)*np.sin(pitch)*np.sin(yaw) - np.cos(yaw)*np.sin(roll),np.cos(pitch)*np.cos(roll))
            a_=a[i-2,0]
            alpha_=alpha[i-2,0]
        else:
            a_=a0
            alpha_=alpha0
        if alpha_!=0:
            d[i-1,0]=-y/np.sin(alpha_)
        else:
            d[i-1,0]=z/np.cos(alpha_)
        theta0[i-1,0]=-np.arctan2(np.cos(yaw)*np.sin(pitch)*np.sin(roll) - np.cos(roll)*np.sin(yaw),np.cos(pitch)*np.cos(yaw))
    
    return a,alpha,d,theta0</code></pre>
</details>
</dd>
<dt id="src.control_func.get_SM"><code class="name flex">
<span>def <span class="ident">get_SM</span></span>(<span>m:Â list, COMs:Â numpy.ndarray, IMs:Â list) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>returns SMs the list of 6 Link Spatial Inertia matrices.
SMs[0]-SMs[5] are the Spatial Inertias of links 1-6.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>list</code></dt>
<dd>list of link masses</dd>
<dt><strong><code>COMs</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,6)</code></dt>
<dd>array of Centres of Mass of the links</dd>
<dt><strong><code>IMs</code></strong> :&ensp;<code>list</code></dt>
<dd>list of Inertia Tensors of the links</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>SMs</code></strong> :&ensp;<code>list</code></dt>
<dd>list of 12 Spatial Inertia Matrices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_SM(m:list,COMs:np.ndarray,IMs:list)-&gt;list:
    &#34;&#34;&#34;returns SMs the list of 6 Link Spatial Inertia matrices.
    SMs[0]-SMs[5] are the Spatial Inertias of links 1-6.

    Parameters
    ----------
    m : list
         list of link masses
    COMs : numpy.ndarray of shape (3,6)
         array of Centres of Mass of the links
    IMs : list
         list of Inertia Tensors of the links

    Returns
    -------
    SMs : list
         list of 12 Spatial Inertia Matrices.

    &#34;&#34;&#34;
    
    SMs=np.zeros((len(m),6,6))
    for i in range(len(m)):
        SM=np.zeros((6,6),dtype=np.float64)
        SM[0:3,0:3]=IMs[i]
        til=tilda(COMs[:,i][:,np.newaxis])
        SM[0:3,3:6]=m[i]*til
        SM[3:6,0:3]=-m[i]*til
        SM[3:6,3:6]=m[i]*np.eye(3,dtype=np.float64)
        SMs[i]=SM
    return SMs    </code></pre>
</details>
</dd>
<dt id="src.control_func.get_cummulative_phi"><code class="name flex">
<span>def <span class="ident">get_cummulative_phi</span></span>(<span>phis:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a array of cummulative rigid body transformation matrices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of 6 rigid body transformation matrices phi_i-1_i for i=1 to 6</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cphis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
phi_i-1_6 for i=1 to 6.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def get_cummulative_phi(phis:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns a array of cummulative rigid body transformation matrices.

    Parameters
    ----------
    phis : numpy.ndarray of shape (6,6,6)
          array of 6 rigid body transformation matrices phi_i-1_i for i=1 to 6

    Returns
    -------
    cphis : numpy.ndarray of shape (6,6,6)
          array of Cummulative Rigid body transformation matrices. cphis[0] to cphis[5] are the cummulative rigid body transformation matrices
        phi_i-1_6 for i=1 to 6. 

    &#34;&#34;&#34;
    
    cphis=np.zeros((6,6,6))
    cphis[5,:,:]=phis[5,:,:]
    for i in [4,3,2,1,0]:
        cphis[i]=phis[i]@cphis[i+1]
        
    return cphis</code></pre>
</details>
</dd>
<dt id="src.control_func.get_phi"><code class="name flex">
<span>def <span class="ident">get_phi</span></span>(<span>alpha:Â numpy.ndarray, a:Â numpy.ndarray, theta0:Â numpy.ndarray, theta:Â numpy.ndarray, d:Â numpy.ndarray, a0:Â float, alpha0:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a 3D arrays of rigid body transformation matrixes for all 6 joints in the Manipulator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of DH parameter alpha for all 6 joints</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of DH parameter a for all 6 joints</dd>
<dt><strong><code>theta0</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of DH parameter theta_0 which is the initial joint angle at home position</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of DH parameter theta which is to be added to initial joint angle to get total joint angle.</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>array of DH parameter d for all 6 joints</dd>
<dt><strong><code>a0</code></strong> :&ensp;<code>float</code></dt>
<dd>base link length</dd>
<dt><strong><code>alpha0</code></strong> :&ensp;<code>float</code></dt>
<dd>base link twist</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
phi_i-1_i for i=1 to 6.</dd>
<dt><strong><code>phis_l</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of link Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
phi_i-1_i for i=1 to 6.</dd>
<dt><strong><code>phis_h</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array of hinge Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
phi_i-1_i for i=1 to 6.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def get_phi(alpha:np.ndarray,a:np.ndarray,theta0:np.ndarray,theta:np.ndarray,d:np.ndarray,a0:float,alpha0:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns a 3D arrays of rigid body transformation matrixes for all 6 joints in the Manipulator

    Parameters
    ----------
    alpha : numpy.ndarray of shape (6,1)
          array of DH parameter alpha for all 6 joints
    a : numpy.ndarray of shape (6,1)
          array of DH parameter a for all 6 joints
    theta0 : numpy.ndarray of shape (6,1)
          array of DH parameter theta_0 which is the initial joint angle at home position
    theta : numpy.ndarray of shape (6,1)
          array of DH parameter theta which is to be added to initial joint angle to get total joint angle.
    d : numpy.ndarray of shape (6,1)
          array of DH parameter d for all 6 joints
    a0 : float
          base link length
    alpha0 : float
          base link twist

    Returns
    -------
    phis : numpy.ndarray of shape (6,6,6)
          array of Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6. 
    phis_l : numpy.ndarray of shape (6,6,6)
          array of link Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6.
    phis_h : numpy.ndarray of shape (6,6,6)
          array of hinge Rigid body transformation matrices. phis[0] to phis[5] are the rigid body transformation matrices
        phi_i-1_i for i=1 to 6.
    &#34;&#34;&#34;

    phis_l=np.zeros((6,6,6))
    phis_h=np.zeros((6,6,6))
    phis=np.zeros((6,6,6))
    for i in range(6):
        if i==0 :
            phis_l[i]=phi_link(d[i,0],a0,alpha0)
        else:
            phis_l[i]=phi_link(d[i,0],a[i-1,0],alpha[i-1,0])
        phis_h[i,:,:]=phi_hinge(theta[i,0]+theta0[i,0])
        phis[i]=phis_l[i] @ phis_h[i]
    return phis,phis_l,phis_h</code></pre>
</details>
</dd>
<dt id="src.control_func.inv_tilda"><code class="name flex">
<span>def <span class="ident">inv_tilda</span></span>(<span>til:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse function of the tilda function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>til</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>3x3 skew-symmetric matix corresponding to the cross-product operation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>3x1 vector corresponding to the input skew-symmetric matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def inv_tilda(til:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Inverse function of the tilda function

    Parameters
    ----------
    til : numpy.ndarray of shape (3,3)
         3x3 skew-symmetric matix corresponding to the cross-product operation

    Returns
    -------
    p : numpy.ndarray of shape (3,1)
         3x1 vector corresponding to the input skew-symmetric matrix

    &#34;&#34;&#34;
    
    p=np.zeros((3,1),dtype=np.float64)
    p[0]=-til[1,2]
    p[1]=til[0,2]
    p[2]=-til[0,1]
    return p</code></pre>
</details>
</dd>
<dt id="src.control_func.joint2task"><code class="name flex">
<span>def <span class="ident">joint2task</span></span>(<span>theta:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Joint Space Coordinates to Task Space Coordinates for the ZYZ Euler Angle Representation of Orientation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Joint Space Coordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Task Space Coordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joint2task(theta:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Converts Joint Space Coordinates to Task Space Coordinates for the ZYZ Euler Angle Representation of Orientation
    
    Parameters
    ----------
    theta : numpy.ndarray of shape (6,1)
         Joint Space Coordinate

    Returns
    -------
    X : numpy.ndarray of shape (6,1)
         Task Space Coordinate
    &#34;&#34;&#34;
    
    X=np.zeros((6,1))
    phis=get_phi(alpha,a,theta0,theta,d,a0,alpha0)[0]
    cphis=get_cummulative_phi(phis)
    ef=np.matmul(cphis[0,:,:],phi6_ef)
    X[0:3]=np.array(euler_from_matrix(ef[0:3,0:3],&#39;rzyz&#39;)).reshape((3,1))
    X[3:6]=pos_from_phi(ef)
    
    return X</code></pre>
</details>
</dd>
<dt id="src.control_func.phi_hinge"><code class="name flex">
<span>def <span class="ident">phi_hinge</span></span>(<span>theta:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Rigid body transformation matrix corresponding to DH parameter theta</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>DH parameter theta (joint angle in radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phi_h</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Rigid Body Transformation Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def phi_hinge(theta:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns Rigid body transformation matrix corresponding to DH parameter theta

    Parameters
    ----------
    theta : float
          DH parameter theta (joint angle in radians)

    Returns
    -------
    phi_h : numpy.ndarray of shape (6,6)
          Rigid Body Transformation Matrix

    &#34;&#34;&#34;
    phi_h=np.zeros((6,6))
    phi_h[0:3,0:3]=phi_h[3:6,3:6]=Rz(theta)
    return phi_h</code></pre>
</details>
</dd>
<dt id="src.control_func.phi_link"><code class="name flex">
<span>def <span class="ident">phi_link</span></span>(<span>d:Â float, a:Â float, alpha:Â float) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Rigid body transformation matrix corresponding to DH parameters d,a and alpha</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>DH parameter d (joint offset in metres)</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>DH parameter a (link length in metres)</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>DH parameter alpha (link twist in radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>phi_l</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>Rigid Body Transformation Matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def phi_link(d:float,a:float,alpha:float)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns Rigid body transformation matrix corresponding to DH parameters d,a and alpha

    Parameters
    ----------
    d : float
          DH parameter d (joint offset in metres)
    a : float
          DH parameter a (link length in metres)
    alpha : float
          DH parameter alpha (link twist in radians)

    Returns
    -------
    phi_l : numpy.ndarray of shape (6,6)
          Rigid Body Transformation Matrix

    &#34;&#34;&#34;
    
    R=Rx(alpha)
    l_tilda=tilda(np.array([[a,-d*np.sin(alpha),d*np.cos(alpha)]]).T)
    phi_l=np.zeros((6,6))
    phi_l[0:3,0:3]=phi_l[3:6,3:6]=R
    phi_l[0:3,3:6]=l_tilda @ R
    
    return phi_l</code></pre>
</details>
</dd>
<dt id="src.control_func.pos_from_phi"><code class="name flex">
<span>def <span class="ident">pos_from_phi</span></span>(<span>phi:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>returns the position coordinates from a rigid body transformation matrix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phi</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>rigid body transformation matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>numpy array of shape (3,1) which is the position coordinates from phi</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def pos_from_phi(phi:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;returns the position coordinates from a rigid body transformation matrix

    Parameters
    ----------
    phi : numpy.ndarray of shape (6,6)
         rigid body transformation matrix

    Returns
    -------
    pos : numpy.ndarray
         numpy array of shape (3,1) which is the position coordinates from phi

    &#34;&#34;&#34;
    
    pos=inv_tilda(phi[0:3,3:6] @ phi[0:3,0:3].T)
    return pos</code></pre>
</details>
</dd>
<dt id="src.control_func.regularize"><code class="name flex">
<span>def <span class="ident">regularize</span></span>(<span>A, cond)</span>
</code></dt>
<dd>
<div class="desc"><p>regularizes input matrix A using a modified truncated SVD regularization using
cond as the threshold condition number</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>input matrix</dd>
<dt><strong><code>cond</code></strong> :&ensp;<code>float</code></dt>
<dd>threshold condition number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>A_</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>regularized matrix</dd>
<dt><strong><code>A_pinv</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>pseudo inverse of regularized matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def regularize(A,cond):
    &#34;&#34;&#34;
    regularizes input matrix A using a modified truncated SVD regularization using
    cond as the threshold condition number

    Parameters
    ----------
    A : numpy.ndarray
         input matrix
    cond : float
         threshold condition number

    Returns
    -------
    A_ : numpy.ndarray
         regularized matrix
    A_pinv: numpy.ndarray
        pseudo inverse of regularized matrix

    &#34;&#34;&#34;
    U,S,Vt=np.linalg.svd(A)

    S=S[S[0]/S&lt;cond]

    S_=np.diag(S)
    n=len(S)
    A_=U[:,0:n] @ S_ @ Vt[0:n,:]#regularized matrix

    S1=1/S
    S1_=np.diag(S1)
    A_pinv=Vt[0:n,:].T @ S1_ @ U[:,0:n].T
    return A_,A_pinv</code></pre>
</details>
</dd>
<dt id="src.control_func.reverse_sweep"><code class="name flex">
<span>def <span class="ident">reverse_sweep</span></span>(<span>phis:Â numpy.ndarray, SMs:Â numpy.ndarray, m:Â numpy.ndarray, V:Â numpy.ndarray, A:Â numpy.ndarray, g:Â numpy.ndarray, H:Â numpy.ndarray, COMs:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out the forward sweep of the Recursive Newton Euler Algorithm</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phis</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,6)</code></dt>
<dd>array rigid body transformation matrices for frames 1 to 6</dd>
<dt><strong><code>SMs</code></strong> :&ensp;<code>list</code></dt>
<dd>list of 6 link spatial inertias</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>list</code></dt>
<dd>list of link masses</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of link spatial velocities</dd>
<dt><strong><code>A</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of link spatial accelerations</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6,1)</code></dt>
<dd>array of link spatial acceleration due to gravity</dd>
<dt><strong><code>H</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Hinge Map Matrix</dd>
<dt><strong><code>COMs</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,6)</code></dt>
<dd>array of Centres of Mass of the links</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>CG</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Vector of Generalised Centripetal, Coriolis and Gravity forces</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def reverse_sweep(phis:np.ndarray,SMs:np.ndarray,m:np.ndarray,V:np.ndarray,A:np.ndarray,g:np.ndarray,H:np.ndarray,COMs:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Carries out the forward sweep of the Recursive Newton Euler Algorithm
    
    Parameters
    ----------
    phis : numpy.ndarray of shape (6,6,6)
         array rigid body transformation matrices for frames 1 to 6
    SMs : list
         list of 6 link spatial inertias 
    m : list
         list of link masses
    V : numpy.ndarray of shape (6,6,1)
         array of link spatial velocities
    A : numpy.ndarray of shape (6,6,1)
         array of link spatial accelerations
    g : numpy.ndarray of shape (6,6,1)
         array of link spatial acceleration due to gravity
    H : numpy.ndarray
         Hinge Map Matrix
    COMs : numpy.ndarray of shape (3,6)
         array of Centres of Mass of the links

    Returns
    -------
    CG : numpy.ndarray of shape (6,1)
         Vector of Generalised Centripetal, Coriolis and Gravity forces
   
    &#34;&#34;&#34;
    
    CG=np.zeros((6,1))
    
    kbk=np.zeros((6,1))
    w=np.zeros((3,1))
    p=np.zeros((3,1))
    v=np.zeros((3,1))
    J=np.zeros((3,3))
    w[:]=V[5][0:3]
    J[:,:]=SMs[5][0:3,0:3]
    p[:,0]=COMs[:,5]
    v[:]=V[5][3:6]
    mk=m[5]
    kbk[0:3]=tilda(w) @ J @ w+mk*tilda(p) @ tilda(w) @ v
    kbk[3:6]=mk* tilda(w) @ tilda(w) @ p+mk*tilda(w) @ v
    Fk=SMs[5] @ (A[5]-g[5])+kbk
    CG[5]=H @ Fk
        
    for k in range(5,0,-1):
        w[:]=V[k-1][0:3]
        J[:,:]=SMs[k-1][0:3,0:3]
        p[:,0]=COMs[:,k-1]
        v[:]=V[k-1][3:6]
        mk=m[k-1]
        kbk[0:3]=tilda(w) @ J @ w +mk*tilda(p) @ tilda(w) @ v
        kbk[3:6]=mk*tilda(w) @ tilda(w) @ p+mk*tilda(w) @ v
        Fk[:,:]=phis[k] @ Fk+SMs[k-1] @ (A[k-1]-g[k-1])+kbk
        CG[k-1]=H @ Fk
               
    return CG</code></pre>
</details>
</dd>
<dt id="src.control_func.state_difference"><code class="name flex">
<span>def <span class="ident">state_difference</span></span>(<span>Xg, Xs)</span>
</code></dt>
<dd>
<div class="desc"><p>The function which gives the difference between task space coordinates
Xg and Xs as per the Euler Angle based scheme.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Xg</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>goal task space coordinate/desired task space coordinate</dd>
<dt><strong><code>Xs</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>start task space coordinate/current task space coordinate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Xd</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>difference between task space coordinates Xg and Xs as per the control scheme.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def state_difference(Xg,Xs):
    &#34;&#34;&#34;
    The function which gives the difference between task space coordinates
    Xg and Xs as per the Euler Angle based scheme.

    Parameters
    ----------
    Xg : numpy.ndarray
         goal task space coordinate/desired task space coordinate
    Xs : numpy.ndarray
         start task space coordinate/current task space coordinate

    Returns
    -------
    Xd : numpy.ndarray
         difference between task space coordinates Xg and Xs as per the control scheme.

    &#34;&#34;&#34;
    Xd=np.zeros(Xg.shape)
    for i in range(3):
        diff=Xg[i,0]-Xs[i,0]
        if abs(diff)&gt;pi:
            Xd[i,0]=-np.sign(diff)*(2*pi-abs(diff))
        else:
            Xd[i,0]=diff
    Xd[3:6]=Xg[3:6]-Xs[3:6]
    # Xd=Xg-Xs
    # Xde=Xd[0:3]
    # #converting angles greater than pi to equivalent negative angle
    # #done so that the difference indicates the shortest possible path
    # idx=np.abs(Xde)&gt;pi
    # Xde[idx]=-np.sign(Xde[idx])*(2*pi-np.abs(Xde[idx]))
    # Xd[0:3,0]=Xde[0:3,0]
    return Xd</code></pre>
</details>
</dd>
<dt id="src.control_func.tilda"><code class="name flex">
<span>def <span class="ident">tilda</span></span>(<span>p:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the 3x3 skew-symmetric matix corresponding to the cross-product
operation for a given 3x1 vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>list</code> or <code>numpy.ndarray</code> of <code>shape (3,1)</code></dt>
<dd>3x1 input vector</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>til</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (3,3)</code></dt>
<dd>3x3 skew-symmetric matix corresponding to the cross-product operation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def tilda(p:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Returns the 3x3 skew-symmetric matix corresponding to the cross-product
    operation for a given 3x1 vector.

    Parameters
    ----------
    p : list or numpy.ndarray of shape (3,1)
         3x1 input vector

    Returns
    -------
    til : numpy.ndarray of shape (3,3)
         3x3 skew-symmetric matix corresponding to the cross-product operation

    &#34;&#34;&#34;
    
    til=np.array([[0,-p[2,0],p[1,0]],[p[2,0],0,-p[0,0]],[-p[1,0],p[0,0],0]])
    return til</code></pre>
</details>
</dd>
<dt id="src.control_func.tilda6"><code class="name flex">
<span>def <span class="ident">tilda6</span></span>(<span>P:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Tilda operation used in Spatial Vector Algebra.</p>
<h2 id="parameters">Parameters</h2>
<p>P : list or numpy.ndarray of shape (6,)
Input spatial vector</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>til</code></strong> :&ensp;<code>numpy.ndarray</code> of <code>shape (6,6)</code></dt>
<dd>6x6 matrix corresponding to tilda operation on P</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tilda6(P:np.ndarray)-&gt;np.ndarray:
    &#34;&#34;&#34;Tilda operation used in Spatial Vector Algebra.

    Parameters
    ---------- 
    P : list or numpy.ndarray of shape (6,)
         Input spatial vector

    Returns
    -------
    til : numpy.ndarray of shape (6,6)
         6x6 matrix corresponding to tilda operation on P
    &#34;&#34;&#34;
    
    x=P[0:3]
    y=P[3:6]
    x_tilda=tilda(x)
    y_tilda=tilda(y)
    til=np.zeros((6,6),dtype=np.float64)
    til[0:3,0:3]=x_tilda
    til[3:6,3:6]=x_tilda
    til[3:6,0:3]=y_tilda
    return til</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="src.control_func.COMs" href="#src.control_func.COMs">COMs</a></code></li>
<li><code><a title="src.control_func.H" href="#src.control_func.H">H</a></code></li>
<li><code><a title="src.control_func.IMs" href="#src.control_func.IMs">IMs</a></code></li>
<li><code><a title="src.control_func.SMs" href="#src.control_func.SMs">SMs</a></code></li>
<li><code><a title="src.control_func.a" href="#src.control_func.a">a</a></code></li>
<li><code><a title="src.control_func.a0" href="#src.control_func.a0">a0</a></code></li>
<li><code><a title="src.control_func.alpha" href="#src.control_func.alpha">alpha</a></code></li>
<li><code><a title="src.control_func.alpha0" href="#src.control_func.alpha0">alpha0</a></code></li>
<li><code><a title="src.control_func.d" href="#src.control_func.d">d</a></code></li>
<li><code><a title="src.control_func.m" href="#src.control_func.m">m</a></code></li>
<li><code><a title="src.control_func.phi6_ef" href="#src.control_func.phi6_ef">phi6_ef</a></code></li>
<li><code><a title="src.control_func.theta0" href="#src.control_func.theta0">theta0</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.control_func.R2Euler" href="#src.control_func.R2Euler">R2Euler</a></code></li>
<li><code><a title="src.control_func.Rx" href="#src.control_func.Rx">Rx</a></code></li>
<li><code><a title="src.control_func.Ry" href="#src.control_func.Ry">Ry</a></code></li>
<li><code><a title="src.control_func.Rz" href="#src.control_func.Rz">Rz</a></code></li>
<li><code><a title="src.control_func.compute_D" href="#src.control_func.compute_D">compute_D</a></code></li>
<li><code><a title="src.control_func.create_IM" href="#src.control_func.create_IM">create_IM</a></code></li>
<li><code><a title="src.control_func.dJ_dt" href="#src.control_func.dJ_dt">dJ_dt</a></code></li>
<li><code><a title="src.control_func.dJ_dt_" href="#src.control_func.dJ_dt_">dJ_dt_</a></code></li>
<li><code><a title="src.control_func.dJi_dt" href="#src.control_func.dJi_dt">dJi_dt</a></code></li>
<li><code><a title="src.control_func.dR_dt" href="#src.control_func.dR_dt">dR_dt</a></code></li>
<li><code><a title="src.control_func.dTe" href="#src.control_func.dTe">dTe</a></code></li>
<li><code><a title="src.control_func.dphih_dq" href="#src.control_func.dphih_dq">dphih_dq</a></code></li>
<li><code><a title="src.control_func.dphis_dq" href="#src.control_func.dphis_dq">dphis_dq</a></code></li>
<li><code><a title="src.control_func.euler2omega_jacobian" href="#src.control_func.euler2omega_jacobian">euler2omega_jacobian</a></code></li>
<li><code><a title="src.control_func.forward_sweep" href="#src.control_func.forward_sweep">forward_sweep</a></code></li>
<li><code><a title="src.control_func.geometric2analytic_jacobian" href="#src.control_func.geometric2analytic_jacobian">geometric2analytic_jacobian</a></code></li>
<li><code><a title="src.control_func.geometric_jacobian" href="#src.control_func.geometric_jacobian">geometric_jacobian</a></code></li>
<li><code><a title="src.control_func.get_DH" href="#src.control_func.get_DH">get_DH</a></code></li>
<li><code><a title="src.control_func.get_SM" href="#src.control_func.get_SM">get_SM</a></code></li>
<li><code><a title="src.control_func.get_cummulative_phi" href="#src.control_func.get_cummulative_phi">get_cummulative_phi</a></code></li>
<li><code><a title="src.control_func.get_phi" href="#src.control_func.get_phi">get_phi</a></code></li>
<li><code><a title="src.control_func.inv_tilda" href="#src.control_func.inv_tilda">inv_tilda</a></code></li>
<li><code><a title="src.control_func.joint2task" href="#src.control_func.joint2task">joint2task</a></code></li>
<li><code><a title="src.control_func.phi_hinge" href="#src.control_func.phi_hinge">phi_hinge</a></code></li>
<li><code><a title="src.control_func.phi_link" href="#src.control_func.phi_link">phi_link</a></code></li>
<li><code><a title="src.control_func.pos_from_phi" href="#src.control_func.pos_from_phi">pos_from_phi</a></code></li>
<li><code><a title="src.control_func.regularize" href="#src.control_func.regularize">regularize</a></code></li>
<li><code><a title="src.control_func.reverse_sweep" href="#src.control_func.reverse_sweep">reverse_sweep</a></code></li>
<li><code><a title="src.control_func.state_difference" href="#src.control_func.state_difference">state_difference</a></code></li>
<li><code><a title="src.control_func.tilda" href="#src.control_func.tilda">tilda</a></code></li>
<li><code><a title="src.control_func.tilda6" href="#src.control_func.tilda6">tilda6</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>