<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.task_controller API documentation</title>
<meta name="description" content="Created on Tue Jun
1 21:39:56 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.task_controller</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Jun
1 21:39:56 2021</p>
<p>@author: dsubhasish</p>
<p>The class defined here can be used as a template for writing code for more
complex task space controllers. Currently no constraints have been applied.
This will be changed in future versions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Jun  1 21:39:56 2021

@author: dsubhasish

The class defined here can be used as a template for writing code for more 
complex task space controllers. Currently no constraints have been applied. 
This will be changed in future versions.
&#34;&#34;&#34;
import numpy as np
from numba import jit
import rospy
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
from control_func import *
import pickle
import time
import matplotlib.pyplot as plt


@jit(nopython=True,cache=True)
def compute_torque(theta,dtheta,Xd,dXd,ddXd,Kd,Kp):
    &#34;&#34;&#34;
    Carries out one iteration of command torque computation.
    
    Takes current joint space position and velocity, uses it to get the rigid 
    body transformation matrices and calculate the Analytical Jacobian and its 
    time derivative. The Jacobian matrix is then regularized and its pseudo-
    inverse is taken.The required task to be performed is then computed, and 
    using the pseudo inverse of the Jacobian, the required joint space acceleration
    is obtained. The command torque is finally obtained by means of inverse 
    dynamics.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    #get current joint state and joint velocity
    
    #get rigid body transformation matrices and cumulative rigid body transformation matrices
    phis,phis_l,_=get_phi(alpha,a,theta0,theta,d,a0,alpha0)
    cphis=get_cummulative_phi(phis)
    #rigid body transformation from base frame to end effector frame
    ef=cphis[0] @ phi6_ef
    #get current task space coordinate
    task_spatial_pos=np.concatenate((R2Euler(ef[0:3,0:3]),pos_from_phi(ef)),axis=0)
    euler=task_spatial_pos[0:3]#get current euler angle
    Ta_inv=geometric2analytic_jacobian(euler)#matrix to be premultiplied with geometric jacobian
    J,J_,R06=geometric_jacobian(cphis)#get geometric jacobian
    Ja_=Ta_inv @ J#analytical jacobian

    Ja=Ja_.copy()#to separate from regularized analytical jacobian

    task_spatial_vel=Ja @ dtheta#current task space velocity
    Jd=dJ_dt(J_,R06,phis,phis_l,cphis,theta,dtheta,6)#derivative of geometric jacobian
    deuler=task_spatial_vel[0:3]#euler angle rate
    dte=dTe(euler,deuler)
    Jad=Ta_inv @ (Jd-dte @ Ja)#derivative of analytical jacobian
    
    Ja_,Ja_inv=regularize(Ja,100)#regularize
    err=state_difference(Xd,task_spatial_pos)#error
    # print(100*np.linalg.norm(err)/np.linalg.norm(self.task_spatial_pos))
    derr=dXd-task_spatial_vel#derivative error
    #command torque computation
    Bt=ddXd+Kd * derr +Kp * err-Jad @ dtheta
    qdd=Ja_inv @ Bt+(np.eye(6)-(Ja_inv @ Ja_)) @ (100-theta+20-dtheta)
    D=compute_D(SMs, phis,H)
    V,A,g=forward_sweep(theta0,theta,dtheta,phis,H)
    CG= reverse_sweep(phis,SMs,m,V,A,g,H,COMs)
    Tc= D @ qdd +CG
    return Tc
    
class Task_Controller(object):
    &#34;&#34;&#34;A bare bones implementation of a task space controller
    
    This controller object receives current joint state messages from 
    /manipulator/joint_states topic and the desired task space trajectory from 
    the /task_desired topic. It then computes the command torque and sends it
    to Gazebo through the /manipulator/group_effort_controller/command topic.

    Attributes
    ----------
    joint_state : JointState
        Current joint state received from Gazebo.
    theta : np.ndarray of shape (6,1)
        Current joint angle vector.
    dtheta : np.ndarray of shape (6,1)
        Current joint velocity vector
    traj_sub : rospy.Subscriber
        Subscriber of desired joint trajectory topic (/task_desired).
    joint_state_sub : rospy.Subscriber
        Subscriber of current joint state topic (/manipulator/joint_states).
    torque_pub : rospy.Publisher
        Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.
    Kp : float
        Kp gain.
    Kd : float
        Kd gain.
    f : float
        Torque publishing frequency
    Xd : np.ndarray of shape (6,1)
        Desired task space position
    dXd : np.ndarray of shape (6,1)
        Desired task space velocity
    ddXd : np.ndarray of shape (6,1)
        Desired task space acceleration
    Tc : np.ndarray of shape (6,1)
        Command torque
    msg : Float64MultiArray
        Torque message to be published
    &#34;&#34;&#34;
    
    def __init__(self,Kp=100,Kd=20,f=200):
        &#34;&#34;&#34;
        Parameters
        ----------
        Kp : TYPE, float
             The default is 100.
        Kd : TYPE, float
             The default is 20.
        f : TYPE, float
             The default is 200.Frequency at which to publish torque
        &#34;&#34;&#34;
        
        self.Kp=Kp
        self.Kd=Kd
        self.joint_state=JointState()#stores joint state message
        #setting initial values
        self.joint_state.position=6*[0]
        self.joint_state.velocity=6*[0]
        #joint state subscriber
        self.joint_state_sub=rospy.Subscriber(&#39;/manipulator/joint_states&#39;, JointState, self.update_state,queue_size=1) #subscriber for joint state
        self.theta=np.zeros((6,1))#current joint angle
        self.dtheta=np.zeros((6,1))#current joint velocity
        self.f=f#torque publishing frequency
        
        #initial desired task space coordinate, task space velocity and task space acceleration
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.Xd=joint2task(theta)
        self.dXd=np.zeros((6,1))
        self.ddXd=np.zeros((6,1))

        self.Tc=np.zeros((6,1))#computed joint torque
        #torque publisher
        self.torque_pub=rospy.Publisher(&#39;/manipulator/group_effort_controller/command&#39;,Float64MultiArray,queue_size=1,latch=True)#command torque publisher
        self.msg=Float64MultiArray()#torque message to be published
        
        #subscriber for desired task space trajectory
        self.traj_sub=rospy.Subscriber(&#39;/task_desired&#39;, Float64MultiArray, self.update_desired_task,queue_size=1) #subscribing to /theta_desired
        

    def update_state(self,msg):
        &#34;&#34;&#34;
        Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

        Parameters
        ----------
        msg : JointState
             Message received on /hhumanoid/joint_states

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.joint_state.position=msg.position
        self.joint_state.velocity=msg.velocity
        self.joint_state.header=msg.header
        
    def update_desired_task(self,msg):
        &#34;&#34;&#34;
        Call back function for desired task space trajectory topic. Updates corresponding values 
        for command torque computation

        Parameters
        ----------
        msg : Float64MultiArray
             message within the desired task space trajectory topic

        Returns
        -------
        None.

        &#34;&#34;&#34;
        traj=msg.data
        self.Xd[0:6,0]=traj[0:6]
        self.dXd[0:6,0]=traj[6:12]
        self.ddXd[0:6,0]=traj[12:18]

    def control_loop(self):
        &#34;&#34;&#34;
        Carries out one iteration of torque computation, followed by publishing
        the torque to /manipulator/group_effort_controller/command.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        r=rospy.Rate(self.f)

        while not rospy.is_shutdown():
            self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
            # self.compute_torque()#compute torque
            self.Tc[:,:]=compute_torque(self.theta,self.dtheta,self.Xd,self.dXd,self.ddXd,self.Kd,self.Kp)

            self.msg.data=self.Tc[:]#message to be published
            try:
                self.torque_pub.publish(self.msg)#publish
                r.sleep()
            except:
                break
    
    def get_time(self):
        &#34;&#34;&#34;
        helper function to get current time from the joint state

        Returns
        -------
        t : float
             current time

        &#34;&#34;&#34;
        header=self.joint_state.header
        t=header.stamp.secs+header.stamp.nsecs*10**-9
        return t
 
if __name__ == &#39;__main__&#39;:
    rospy.init_node(&#39;torque_commander&#39;)#start node
    task=Task_Controller()#initialize controller
    task.control_loop()#start torque computation loop</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.task_controller.compute_torque"><code class="name flex">
<span>def <span class="ident">compute_torque</span></span>(<span>theta, dtheta, Xd, dXd, ddXd, Kd, Kp)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out one iteration of command torque computation.</p>
<p>Takes current joint space position and velocity, uses it to get the rigid
body transformation matrices and calculate the Analytical Jacobian and its
time derivative. The Jacobian matrix is then regularized and its pseudo-
inverse is taken.The required task to be performed is then computed, and
using the pseudo inverse of the Jacobian, the required joint space acceleration
is obtained. The command torque is finally obtained by means of inverse
dynamics.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True,cache=True)
def compute_torque(theta,dtheta,Xd,dXd,ddXd,Kd,Kp):
    &#34;&#34;&#34;
    Carries out one iteration of command torque computation.
    
    Takes current joint space position and velocity, uses it to get the rigid 
    body transformation matrices and calculate the Analytical Jacobian and its 
    time derivative. The Jacobian matrix is then regularized and its pseudo-
    inverse is taken.The required task to be performed is then computed, and 
    using the pseudo inverse of the Jacobian, the required joint space acceleration
    is obtained. The command torque is finally obtained by means of inverse 
    dynamics.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    #get current joint state and joint velocity
    
    #get rigid body transformation matrices and cumulative rigid body transformation matrices
    phis,phis_l,_=get_phi(alpha,a,theta0,theta,d,a0,alpha0)
    cphis=get_cummulative_phi(phis)
    #rigid body transformation from base frame to end effector frame
    ef=cphis[0] @ phi6_ef
    #get current task space coordinate
    task_spatial_pos=np.concatenate((R2Euler(ef[0:3,0:3]),pos_from_phi(ef)),axis=0)
    euler=task_spatial_pos[0:3]#get current euler angle
    Ta_inv=geometric2analytic_jacobian(euler)#matrix to be premultiplied with geometric jacobian
    J,J_,R06=geometric_jacobian(cphis)#get geometric jacobian
    Ja_=Ta_inv @ J#analytical jacobian

    Ja=Ja_.copy()#to separate from regularized analytical jacobian

    task_spatial_vel=Ja @ dtheta#current task space velocity
    Jd=dJ_dt(J_,R06,phis,phis_l,cphis,theta,dtheta,6)#derivative of geometric jacobian
    deuler=task_spatial_vel[0:3]#euler angle rate
    dte=dTe(euler,deuler)
    Jad=Ta_inv @ (Jd-dte @ Ja)#derivative of analytical jacobian
    
    Ja_,Ja_inv=regularize(Ja,100)#regularize
    err=state_difference(Xd,task_spatial_pos)#error
    # print(100*np.linalg.norm(err)/np.linalg.norm(self.task_spatial_pos))
    derr=dXd-task_spatial_vel#derivative error
    #command torque computation
    Bt=ddXd+Kd * derr +Kp * err-Jad @ dtheta
    qdd=Ja_inv @ Bt+(np.eye(6)-(Ja_inv @ Ja_)) @ (100-theta+20-dtheta)
    D=compute_D(SMs, phis,H)
    V,A,g=forward_sweep(theta0,theta,dtheta,phis,H)
    CG= reverse_sweep(phis,SMs,m,V,A,g,H,COMs)
    Tc= D @ qdd +CG
    return Tc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.task_controller.Task_Controller"><code class="flex name class">
<span>class <span class="ident">Task_Controller</span></span>
<span>(</span><span>Kp=100, Kd=20, f=200)</span>
</code></dt>
<dd>
<div class="desc"><p>A bare bones implementation of a task space controller</p>
<p>This controller object receives current joint state messages from
/manipulator/joint_states topic and the desired task space trajectory from
the /task_desired topic. It then computes the command torque and sends it
to Gazebo through the /manipulator/group_effort_controller/command topic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>joint_state</code></strong> :&ensp;<code>JointState</code></dt>
<dd>Current joint state received from Gazebo.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current joint angle vector.</dd>
<dt><strong><code>dtheta</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Current joint velocity vector</dd>
<dt><strong><code>traj_sub</code></strong> :&ensp;<code>rospy.Subscriber</code></dt>
<dd>Subscriber of desired joint trajectory topic (/task_desired).</dd>
<dt><strong><code>joint_state_sub</code></strong> :&ensp;<code>rospy.Subscriber</code></dt>
<dd>Subscriber of current joint state topic (/manipulator/joint_states).</dd>
<dt><strong><code>torque_pub</code></strong> :&ensp;<code>rospy.Publisher</code></dt>
<dd>Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.</dd>
<dt><strong><code>Kp</code></strong> :&ensp;<code>float</code></dt>
<dd>Kp gain.</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>float</code></dt>
<dd>Kd gain.</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>float</code></dt>
<dd>Torque publishing frequency</dd>
<dt><strong><code>Xd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space position</dd>
<dt><strong><code>dXd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space velocity</dd>
<dt><strong><code>ddXd</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Desired task space acceleration</dd>
<dt><strong><code>Tc</code></strong> :&ensp;<code>np.ndarray</code> of <code>shape (6,1)</code></dt>
<dd>Command torque</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>Float64MultiArray</code></dt>
<dd>Torque message to be published</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Kp</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 100.</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 20.</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>TYPE, float</code></dt>
<dd>The default is 200.Frequency at which to publish torque</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task_Controller(object):
    &#34;&#34;&#34;A bare bones implementation of a task space controller
    
    This controller object receives current joint state messages from 
    /manipulator/joint_states topic and the desired task space trajectory from 
    the /task_desired topic. It then computes the command torque and sends it
    to Gazebo through the /manipulator/group_effort_controller/command topic.

    Attributes
    ----------
    joint_state : JointState
        Current joint state received from Gazebo.
    theta : np.ndarray of shape (6,1)
        Current joint angle vector.
    dtheta : np.ndarray of shape (6,1)
        Current joint velocity vector
    traj_sub : rospy.Subscriber
        Subscriber of desired joint trajectory topic (/task_desired).
    joint_state_sub : rospy.Subscriber
        Subscriber of current joint state topic (/manipulator/joint_states).
    torque_pub : rospy.Publisher
        Publisher of computed command torque to the /manipulator/group_effort_controller/command topic.
    Kp : float
        Kp gain.
    Kd : float
        Kd gain.
    f : float
        Torque publishing frequency
    Xd : np.ndarray of shape (6,1)
        Desired task space position
    dXd : np.ndarray of shape (6,1)
        Desired task space velocity
    ddXd : np.ndarray of shape (6,1)
        Desired task space acceleration
    Tc : np.ndarray of shape (6,1)
        Command torque
    msg : Float64MultiArray
        Torque message to be published
    &#34;&#34;&#34;
    
    def __init__(self,Kp=100,Kd=20,f=200):
        &#34;&#34;&#34;
        Parameters
        ----------
        Kp : TYPE, float
             The default is 100.
        Kd : TYPE, float
             The default is 20.
        f : TYPE, float
             The default is 200.Frequency at which to publish torque
        &#34;&#34;&#34;
        
        self.Kp=Kp
        self.Kd=Kd
        self.joint_state=JointState()#stores joint state message
        #setting initial values
        self.joint_state.position=6*[0]
        self.joint_state.velocity=6*[0]
        #joint state subscriber
        self.joint_state_sub=rospy.Subscriber(&#39;/manipulator/joint_states&#39;, JointState, self.update_state,queue_size=1) #subscriber for joint state
        self.theta=np.zeros((6,1))#current joint angle
        self.dtheta=np.zeros((6,1))#current joint velocity
        self.f=f#torque publishing frequency
        
        #initial desired task space coordinate, task space velocity and task space acceleration
        theta=np.array([[0,pi/3,-pi/2,0,pi/3,0]]).T
        self.Xd=joint2task(theta)
        self.dXd=np.zeros((6,1))
        self.ddXd=np.zeros((6,1))

        self.Tc=np.zeros((6,1))#computed joint torque
        #torque publisher
        self.torque_pub=rospy.Publisher(&#39;/manipulator/group_effort_controller/command&#39;,Float64MultiArray,queue_size=1,latch=True)#command torque publisher
        self.msg=Float64MultiArray()#torque message to be published
        
        #subscriber for desired task space trajectory
        self.traj_sub=rospy.Subscriber(&#39;/task_desired&#39;, Float64MultiArray, self.update_desired_task,queue_size=1) #subscribing to /theta_desired
        

    def update_state(self,msg):
        &#34;&#34;&#34;
        Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

        Parameters
        ----------
        msg : JointState
             Message received on /hhumanoid/joint_states

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.joint_state.position=msg.position
        self.joint_state.velocity=msg.velocity
        self.joint_state.header=msg.header
        
    def update_desired_task(self,msg):
        &#34;&#34;&#34;
        Call back function for desired task space trajectory topic. Updates corresponding values 
        for command torque computation

        Parameters
        ----------
        msg : Float64MultiArray
             message within the desired task space trajectory topic

        Returns
        -------
        None.

        &#34;&#34;&#34;
        traj=msg.data
        self.Xd[0:6,0]=traj[0:6]
        self.dXd[0:6,0]=traj[6:12]
        self.ddXd[0:6,0]=traj[12:18]

    def control_loop(self):
        &#34;&#34;&#34;
        Carries out one iteration of torque computation, followed by publishing
        the torque to /manipulator/group_effort_controller/command.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        r=rospy.Rate(self.f)

        while not rospy.is_shutdown():
            self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
            # self.compute_torque()#compute torque
            self.Tc[:,:]=compute_torque(self.theta,self.dtheta,self.Xd,self.dXd,self.ddXd,self.Kd,self.Kp)

            self.msg.data=self.Tc[:]#message to be published
            try:
                self.torque_pub.publish(self.msg)#publish
                r.sleep()
            except:
                break
    
    def get_time(self):
        &#34;&#34;&#34;
        helper function to get current time from the joint state

        Returns
        -------
        t : float
             current time

        &#34;&#34;&#34;
        header=self.joint_state.header
        t=header.stamp.secs+header.stamp.nsecs*10**-9
        return t</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.task_controller.Task_Controller.control_loop"><code class="name flex">
<span>def <span class="ident">control_loop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carries out one iteration of torque computation, followed by publishing
the torque to /manipulator/group_effort_controller/command.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def control_loop(self):
    &#34;&#34;&#34;
    Carries out one iteration of torque computation, followed by publishing
    the torque to /manipulator/group_effort_controller/command.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    r=rospy.Rate(self.f)

    while not rospy.is_shutdown():
        self.theta[0:6,0],self.dtheta[0:6,0]=self.joint_state.position[0:6],self.joint_state.velocity[0:6]
        # self.compute_torque()#compute torque
        self.Tc[:,:]=compute_torque(self.theta,self.dtheta,self.Xd,self.dXd,self.ddXd,self.Kd,self.Kp)

        self.msg.data=self.Tc[:]#message to be published
        try:
            self.torque_pub.publish(self.msg)#publish
            r.sleep()
        except:
            break</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to get current time from the joint state</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>current time</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time(self):
    &#34;&#34;&#34;
    helper function to get current time from the joint state

    Returns
    -------
    t : float
         current time

    &#34;&#34;&#34;
    header=self.joint_state.header
    t=header.stamp.secs+header.stamp.nsecs*10**-9
    return t</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.update_desired_task"><code class="name flex">
<span>def <span class="ident">update_desired_task</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Call back function for desired task space trajectory topic. Updates corresponding values
for command torque computation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>Float64MultiArray</code></dt>
<dd>message within the desired task space trajectory topic</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_desired_task(self,msg):
    &#34;&#34;&#34;
    Call back function for desired task space trajectory topic. Updates corresponding values 
    for command torque computation

    Parameters
    ----------
    msg : Float64MultiArray
         message within the desired task space trajectory topic

    Returns
    -------
    None.

    &#34;&#34;&#34;
    traj=msg.data
    self.Xd[0:6,0]=traj[0:6]
    self.dXd[0:6,0]=traj[6:12]
    self.ddXd[0:6,0]=traj[12:18]</code></pre>
</details>
</dd>
<dt id="src.task_controller.Task_Controller.update_state"><code class="name flex">
<span>def <span class="ident">update_state</span></span>(<span>self, msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>JointState</code></dt>
<dd>Message received on /hhumanoid/joint_states</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_state(self,msg):
    &#34;&#34;&#34;
    Call back function for joint state subscriber. Updates self.theta and self.thetad whenever a new joint state message is received

    Parameters
    ----------
    msg : JointState
         Message received on /hhumanoid/joint_states

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self.joint_state.position=msg.position
    self.joint_state.velocity=msg.velocity
    self.joint_state.header=msg.header</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.task_controller.compute_torque" href="#src.task_controller.compute_torque">compute_torque</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.task_controller.Task_Controller" href="#src.task_controller.Task_Controller">Task_Controller</a></code></h4>
<ul class="">
<li><code><a title="src.task_controller.Task_Controller.control_loop" href="#src.task_controller.Task_Controller.control_loop">control_loop</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.get_time" href="#src.task_controller.Task_Controller.get_time">get_time</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.update_desired_task" href="#src.task_controller.Task_Controller.update_desired_task">update_desired_task</a></code></li>
<li><code><a title="src.task_controller.Task_Controller.update_state" href="#src.task_controller.Task_Controller.update_state">update_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>